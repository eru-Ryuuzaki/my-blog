## 四月，你好，莫负春光，莫负自己。

> 以下面经仅抽取原作者的问题部分，回答内容是本人根据个人情况来作答的。

### 2022-4-11（提效！提效！提效！提效！提效！提效！）

+ 一篇面经

  >
  >
  >作者：白玉川
  >链接：https://www.nowcoder.com/discuss/925386?source_id=discuss_experience_nctrack&channel=-1
  >来源：牛客网
  >
  >1.介绍一下项目
  >
  >> 这个项目是对于element plus进行的二次封装，由于element plus中的组件为了兼顾通用性，利于开发人员进行拓展，所以有些组件的功能并不是特别丰富，在日常的开发场景中，为了完成需求，也还是得进行二次封装。这个项目就是结合了一下日常常见的开发场景，对一些组件进行二次封装，并且打包后当做 npm 包来发布，在遇到那些常见的开发场景的时候，就可以引入使用，提高开发效率。同时也支持按需引入。
  >
  >2.怎么想去做这个项目的，你的项目是实习项目还是课程作业
  >
  >> 一来是为了加强自己的封装能力，然后就是，以后有个想法就是想尝试做一个自己的组件库的，就当做提前了解了一些组件的设计吧。而且感觉这种需求场景，也就是对于组件的二次封装，以后有个会经常遇到的，就提前巩固一下。
  >
  >3.说一说vue响应式的理解
  >
  >> 官网解释：Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。
  >> 	实现原理：
  >> 	vue2版：
  >> 	Vue在组件实例初始化的时候，会将data里的数据进行数据劫持(object.definepropty对数据做处理)。被解除过后的数据会有两个属性：一个叫getter，一个叫setter。
  >>
  >> getter是使用数据的时候触发，setter是在修改数据的时候触发，修改数据的时候触发setter，同时也触发了底层的watcher监听，通知dom修改刷新。
  >> （ps：对于对象上新增的属性无能为力，还有修改数组的时候，直接原地修改数据是不起效果的(其实是为了节约性能)）
  >> 	vue3版：
  >> 	Vue3重写了响应式系统，和Vue2相比底层采用Proxy对象实现，在初始化的时候不需要遍历所有的属性再把属性通过defineProperty转换成get和set。另外如果有多层属性嵌套的话只有访问某个属性的时候才会递归处理下一级的属性所以Vue3中响应式系统的性能要比Vue2好。
  >> Vue3的响应式系统可以监听动态添加的属性还可以监听属性的删除操作，以及数组的索引以及length属性的修改操作。另外Vue3的响应式系统还可以作为模块单独使用。
  >
  >4.组件通信方式
  >
  >> 1.props/$emits
  >> 2.eventBus
  >> 3.vuex
  >> 4.refs
  >> 5.parent、children、root
  >> 6.provide、inject
  >> 7.attrs、listeners
  >> 8.localStorage、sessionStorage
  >> 9.v-model（还有些疑惑） 
  >
  >5.节流和防抖
  >
  >> 节流
  >>
  >> ​	function throttle(fn, delay) {
  >> ​		let timer = null;
  >> ​		return function(...args) {
  >> ​			if (timer)	return;
  >> ​			timer = setTimeout(() => {
  >> ​				fn.apply(this, args);
  >> ​				// 复盘更改
  >> ​				clearTimeout(timer); -> 应为 timer = null;
  >> ​			}, delay);
  >> ​		}
  >> ​	}
  >> ​	防抖
  >> ​	function debounce(fn, delay) {
  >> ​		let timer = null;
  >> ​		return function(...args) {
  >> ​			timer && clearTimeout(timer);
  >> ​			timer = setTimeout(() => {
  >> ​            	fn.apply(this, args);
  >> ​            }, delay);
  >> ​		}
  >> ​	}
  >
  >6.scss和less与css的区别
  >
  >> scss和less 是预处理器，有助于减少CSS的重复，节省时间。它是更稳定 和强大的CSS扩展语言，描述文档的样式干净和结构清晰。
  >
  >7.有什么你擅长但我没问到的地方嘛
  >
  >> 算法，出题吧
  >
  >8.大学参加过社团嘛进行过团队合作什么的
  >
  >> 加入了一个实验室，有和他们一起做过一些项目什么的。
  >
  >9.为什么要做前端
  >
  >> 首先最重要的一点是，相比于其他的方向，自己更加喜欢前端吧。当然也考虑过算法、后端开发这些岗位，这些岗位更加不仅竞争大，而且做项目的时候，更加正反馈没有前端来的那么强，这也是前端比较有意思的一个地方吧，自己写了一个页面，然后就可以立即看到这个页面张什么样子，就感觉挺有成就感的。
  >
  >10.对恒生有什么了解
  >
  >> 无了解，寄
  >> 如果是很感兴趣的公司，当然就需要提前去了解一下，如果不感兴趣的可能就...随其自然吧
  >
  >11.有什么想问的嘛
  >
  >> 想问一下我现在面试的这个部门技术栈用的是什么
  >> 对于我刚刚面试的表现，能不能给一些建议呢？
  >> 计算机基础对于前端的重要性

  

  + 总结+整理

  + 自己问自己

+ 学习 vue-router （未完成）

  + 看 vue-router 源码
  + 尝试跟着手写一个 vue-router
  

### 2022-4-12

+ 一篇面经

  > 作者：海绵宝宝_front-end
  > 链接：https://www.nowcoder.com/discuss/926446
  > 来源：牛客网
  >
  > ## 一面 
  > 1.自我介绍
  >
  > > 面试官您好，我叫李裕湛，是东莞理工学院计算机科学与技术专业的一名大三学生，应聘的是前端的暑期实习。我个人相比于其他人可能接触开发比较晚，我是大二下学期加入了实验室才开始接触前端的。在这之前，我曾经一度以为以后的工作都是围绕这数据结构与算法来展开的，因为之前在很多地方都看到有人说程序=数据结构+算法嘛。然后自从我大一上学期学了c语言之后，就开始提前学了数据结构与算法，并且在洛谷、力扣啊那些地方零零散散地做一些题，也去参加了蓝桥杯，取得了自己还算满意的成绩。直到接触到开发之后，才发现还有好多东西也学的，仅仅是算法的话，做不了一些工程上的事情。所以感觉自己在工程上，有些经验并不是很足，但是也有过几个项目的开发经验。
  > 
  > 2.看代码说输出
  > 
  > ```js
  >     inner = 0
  >     function say(){
  >      console.log(inner)	
  >       console.log(this.inner)
  >     }
  >     let obj1 = {
  >       inner:'1-1',
  >       say(){
  >         let inner = '1-2'
  >         console.log(inner)
  >         console.log(this.inner)
  >       }
  >     }
  >     let obj2 = {
  >       inner:'2-1',
  >       say(){
  >         let inner = '2-2'
  >         console.log(inner)
  >         console.log(this.inner)
  >       }
  >     }
  >     say()	// 0	undefined(×) 这里应该是 0, 因为这里 say() 的调用对象是 windows
  >     obj1.say()	// '1-2'	'1-1'
  >     obj2.say()	// '2-2'	'2-1'
  >     obj1.say = say  
  >     obj1.say()	// 0 '1-1'
  >     obj2.say = obj1.say
  >     obj2.say()	// 0 '2-1'
  > ```
  > 
  > 3.知道promise嘛？说一下是做什么的？为什么可以链式调用？如果返回个promise怎么处理？它的then方法和catch方法关系？promise的错误捕获怎么做的？
  > 
  > > promise 是异步编程的一个解决方案。因为又返回了一个promise。
  >
  > 4.说一下eventloop？微任务里面嵌套一个微任务怎么执行？（执行栈 任务队列）
  >
  > > 众所周知JavaScript是⼀⻔单线程的语⾔，所以在JavaScript的世界中默认的情况下同⼀个时间节点只能做⼀件事情，这样的设定就造成了JavaScript这⻔语⾔的⼀些局限性，⽐如在我们的⻚⾯中加载⼀些远程数据时，如果按照单线程同步的⽅式运⾏，⼀旦有HTTP请求向服务器发送，就会出现等待数据返回之前⽹⻚假死的效果出现。实际上JavaScript的运⾏顺序就是完全单线程的异步模型：同步在前，异步在后。所有的异步任务都要等待当前的同步任务执⾏完毕之后才能执⾏。
  >>
  > > 在了解线程组成前要了解⼀点，虽然浏览器是单线程执⾏JavaScript代码的，但是浏览器实际是以多个线程协助操作来实现单线程异步模型的
  > 	>
  > > 所以我们通常分析时，将上⾯的细分线程归纳为下列两条线程：
  > 	>
  > > 1. 【主线程】：这个线程⽤了执⾏⻚⾯的渲染，JavaScript代码的运⾏，事件的触发等等
  >>
  > > 2. 【⼯作线程】：这个线程是在幕后⼯作的，⽤来处理异步任务的执⾏来实现⾮阻塞的运⾏模式
  > >
  >> **JavaScript**的运⾏模型
  > >
  > > ![](https://s2.loli.net/2022/04/12/ahH1JcNkQ8DPr5q.png)
  > >
  > > **关于执⾏栈**
  > >
  > > 执⾏栈是⼀个栈的数据结构，当我们运⾏单层函数时，执⾏栈执⾏的函数进栈后，会出栈销毁然后下⼀个进栈下⼀
  > >
  > > 个出栈，当有函数嵌套调⽤的时候栈中就会堆积栈帧
  > >
  > > PS：这里就可以引到递归的概念去，递归函数就可以看成是在⼀个函数中嵌套n层执⾏，那么在执⾏过程中会触发⼤量
  > >
  > > 的栈帧堆积，如果处理的数据过⼤，会导致执⾏栈的⾼度不够放置新的栈帧，⽽造成栈溢出的错误。所以我们在做
  > >
  > > 海量数据递归的时候⼀定要注意这个问题。（这里有个 setTimeout 的妙用）
  > >
  > > **宏任务微任务**
  > >
  > > ![](https://s2.loli.net/2022/04/12/eCtyM7d3gJA4N68.png)

  > 5.说一下闭包，作用域，原型链？
  >
  > 
> 6.new内部实现原理？
>
> > 新建了一个对象，并把构建函数作为他的原型，然后返回这个新对象。然后如果构建函数blabla....（感觉会手写new就跟着说就行了）
>
> 7.还是看代码说输出，具体代码不记得，就是关于微任务和宏任务的。
>
> > 好
>
> 8.场景题，给了一个sleep函数， 实现功能，隔1s打印1，再隔2s打印2，隔3秒打印3
>
> ```js
> function sleep(timeout){
> return new Promise((resolve,reject)=>{
>  	setTimeout(resolve,timeout)
>  })
> }
> function main(){
> 	// 写代码
> sleep(1000).then(() => {
>      console.log(1);
>      return sleep(2000);
>  }).then(() => {
>      console.log(2);
>      return sleep(3000);
>  }).then(() => {
>      console.log(3)
>  })
> }
> ```
>
> 更优雅的写法(async await 差点忘记怎么用了 == async写成了 asyn,然后 await 写在了 let 前(其实是写在 = 后))
>
> ```js
> function sleep(timeout){
> return new Promise((resolve,reject)=>{
>  	setTimeout(resolve,timeout)
>  })
> }
> function main(){
> 	// 写代码
> 	await sleep(1000);
> console.log(1)
>  await sleep(2000);
>  console.log(2)
>  await sleep(3000);
>  console.log(3)
> }
> ```
>
> 9.写一下垂直居中的方案，尽可能多的写。
>
> > 下次一定
>
> 10.算法题：两个有序数组排序
> 	一眼双指针
> 11.算法题：简化路径 https://leetcode-cn.com/problems/simplify-path/
>
> ```js
> // 妙啊
> var simplifyPath = function(path) {
>  path = path.split('/')
>      let stack = []
>      console.log(path)
>     for(let p of path){
>          // 两个点表示切换上一级 所以将栈顶弹出
>          if(p === '..'){
>              if(stack.length){
>                  stack.pop()
>              }
>          }
>          // '.'表示当前目录，和''一样没有价值可以无视掉
>          else if(p !== '' && p !== '.' ){
>              stack.push(p)
>          }
>      }
> 	return '/' + stack.join('/')
> };
> ```
> 
> ```
> 反问：
> 1.对我的评价
> 2.技术栈
> 
> ## 二面  3.31 全程35min 面试官有点严肃 😅
> 1.自我介绍
> 2.介绍项目（这里有点忘记了，答的不是很好）
> 3.介绍项目封装的组件，骨架屏是怎么封装的？
> 我明天就学这个！
> 4.vue的created和mounted声明周期都做什么？接口请求在哪里？（都可以）
> 5.骨架屏组件是怎么使用的？（请求回调控制骨架屏显示和隐藏）
> > 就学就学
> 6.虚拟dom的优势？如果用原生js如何实现虚拟dom的作用？（DocumentFragment）
> 7.http和tcp关系？
> 8.在一条tcp可以发送多个http嘛？为什么？（可以，http2的多路复用机制）
> 9.对webpack的了解？基本配置？loader和plugin区别？
> 	从运行时机的角度区分
> 	1 . loader运行在打包文件之前（loader为在模块加载时的预处理文件）  2.  plugins在整个编译周期都起作用。
> 10.手写promise.all
> 11.一个算法题：下一个排列 https://leetcode-cn.com/problems/next-permutation/
> 反问：
> 1.面试表现？
> 基础扎实，但是技术面有点窄，以后实习就好了
> 2.业务？（balabalabala）
> 感觉自己凉了，没想到第三天收到了三面邀请。 😁
> 
> ## 三面 4.8 全程35分钟 面试官很温柔 😁
> 1.自我介绍
> 2.哪些算作前端？（一开始说了安卓，移动端，pc端，ios），面试官说这算做一类
> 3.前端体系？哪些是前端基础，哪些是工程化？（balabalabala）
> 4.平时怎么学前端？（看视频 + 书）
> 5.为什么学前端？
> 6.手写原生ajax
> 7.用promise封装ajax
> 8.会写promise底层吗？（我说会），接着问，现在可以写嘛（我说可以），他说不用了，太费时间了。
> 9.问了js的基本类型？ 如何判断？(说了typeof，instanceof，Object.ptototype.toString)
> 10.instanceof原理？手写一下？
> 11.问了状态码？
> 12.为什么选择电商项目？
> 13.问了数据懒加载和图片懒加载原理？
> 14.浏览器缓存有哪些？（强缓存和协商缓存），又追问了具体字段有哪些？协商缓存的两对字段分别是什么？Etags是什么？（最开始脑子抽了，说是布尔值，又来又改成了contentHash），面试官说对。
> 15.骨架屏有什么用？
> 16.你的项目存在哪些安全隐患？（说了客户端和服务端不同步，会导致订单价格不一致）
> 17.场景提：5点抢红包，如果客户端和服务端时间不一致，怎么办？（说了把客户端的时间发送给服务端，以服务端的时间为准），面试官说对。
> 反问：
> 1.面试表现
> 2.业务
> 抖音上的电商
> ```

+ 学习 vue-router 

  + 看 vue-router 源码
  + 尝试跟着手写一个 vue-router

+ 总结一下模块化



### 2022-4-17

+ 一篇面经

  自我介绍 

  > 事先准备吧

  闭包的概念，好处 

  > 闭包就是一个在别的函数内部返回来的一个函数，他可以在外面访问到别的函数内部的变量。因为一般函数内部的变量外部是访问不到的，而闭包的话就可以访问得到，这样就有利于保护一些私有变量啥的。

  闭包里面的变量为什么不会被回收 

  > 首先，JS 有是存在垃圾回收机制的，一般来说，就有两种，一种是引用计数，一种是标记清除。简单介绍一番之后，可以说一下引用计数的隐患（循环引用）,可能会造成内存泄漏。因为闭包里面的变量还被别的变量引用着，所以不会被回收。

  怎么实现类的继承 

  > 六大类。先背吧。

  了解异步调用栈吗 

  > 不就是 eventloop 的过程吗~ 从同步任务、微任务、宏任务开始讲起。当执行一个 js 文件的时候，其实可以把一整个看成是一个宏任务。当遇到一个微任务的时候，就会把微任务放进一个微任务队列，遇到宏任务，就把宏任务放进一个宏任务队列。不断地循环。

  宏任务A，B和C会就这样执行下去吗（没太听懂，可能问中间又插入一些微任务） 

  > 在有同步代码的时候，必须要先执行完同步代码，微任务队列还有任务的时候，也要先执行完。只有同步代码和微任务都执行完之后，才会执行下一个宏任务。

  说一说事件冒泡，事件委托 

  > 事件冒泡: 从最精确的位置到最模糊的
  >
  > 事件委托：事件委托是利用事件冒泡原理实现的，就是事件目标自身不处理事件，而是把处理任务委托给其父元素或者祖先元素，甚至根元素

  如何阻止事件冒泡 

  > 我们经常利用事件冒泡机制去减少给DOM添加过多的绑定事件即**事件委托**，但是有时候事件冒泡也会比较烦人，影响我们的事件正常处理机制
  >
  > 默认都是冒泡事件，所以只需要阻止冒泡就可以阻止其他的事件发生了
  >
  > stopPropagation()

  阻止原生事件

  > 例如a链接的跳转，form标签的提交等等。
  > 阻止默认事件使用preventDefault()函数，或者在js中return false也可以。

  监听事件的三个参数？ 

  > 可以是一个布尔值
  >
  > 也可以是一个对象
  >
  > 对象的话，里面多几个配置项
  >
  > - 当为 boolean 时：
  >   - 第三个参数涉及到是冒泡还是捕获的时候触发事件：为 true 时是捕获，为 false 时是冒泡。
  > - 当为 Object 时：
  >   - capture： Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。
  >   - once： Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。
  >   - passive：Boolean，设置为 true 时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。
  >   - mozSystemGroup：只能在 XBL 或者是 Firefox' chrome 使用，这是个 Boolean，表示 listener 被添加到 system group。

  自适应水平垂直居中 
  
  > 老生常谈了，写熟一点吧

  说一下变量提升 
  
  > 在 es6 之前，都是用 var 来声明变量的。那些变量都存在变量提升，比如，在中间的位置声明的时候，在执行到这个位置之前，访问这个变量是不会报错的，而是一个undefined，当执行到这个位置的时候，才会执行赋值语句，这个时候那个变量才会拥有这个值。听说函数也存在变量提升的情况，并且函数提升优先于变量提升，也即如果函数和变量同时提升的话，访问的是函数。
  
  编程：第N个字符
  
  > 等差数列

