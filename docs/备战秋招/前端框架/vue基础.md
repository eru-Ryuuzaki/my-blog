---
theme: channing-cyan
---

### vue 和 react 有哪些区别？
1. 数据流
    + vue ：双向数据流
    + react ：单向数据流
2. 编程思想
    + vue ：响应式编程（这里表述好像有点问题但是暂时没找到比较好的词、）
    + react ：函数式编程

### 为什么会有这样的区别？

### 怎么理解 vue 和 nest 这些框架说的渐进式

> 就是一开始不需要你完全掌握它的全部功能特性，可以后续逐步增加功能。没有多做职责之外的事情
>
> + 使用 vue
>
>   1. vue.js只提供了vue-cli生态中最核心的组件系统和双向数据绑定
>
>   2. 就好像 vuex、vue-router都属于围绕vue.js开发的库
>
> + 使用Angular，必须接受以下东西
>
>   1. 必须使用它的模块机制
>
>   2. 必须使用它的依赖注入
>
>   3. 必须使用它的特殊形式定义组件
>
>   所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰
>
> + 使用React，你必须理解
>
>   1. 函数式编程的理念
>
>   2. 需要知道它的副作用
>
>   3. 什么是纯函数
>
>   4. 如何隔离、避免副作用
>
>   它的侵入性看似没有Angular那么强，主要因为它是属于软性侵入的

### MVC 和 MVVM 模式的区别

#### MVC 即模型、视图、控制器（Model View Controller）

> 简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。**controller**在这里执行的的就是别墅里面的“**管家**”的作用。

- View 接受用户交互请求
- View 将请求转交给Controller处理
- Controller 操作Model进行数据更新保存
- 数据更新保存之后，Model会通知View更新
- View 更新变化数据使用户得到反馈

#### MVVM 即模型、视图、视图模型（Model-View-ViewModel），**ViewModel**是MVVM这栋别墅的“**管家**”

- View 接收用户交互请求
- View 将请求转交给ViewModel
- ViewModel 操作Model数据更新
- Model 更新完数据，通知ViewModel数据发生变化
- ViewModel 更新View数据

> MVVM设计模式是自动化的，vue就是采取了这种设计模式，真正把数据和视图分离开的是MVVM模式，并不是MVC，因为controller当中有大量手工的DOM操作，只要界面改变，controller中的代码必须要更改（jquery），比如你可以想象一下，你页面当中元素的位置变了，你的选择器是不是肯定要变，选择器就写在DOM操作里面，这就是MVC和MVVM两种设计模式的区别。

### vue 双向绑定原理（数据劫持+发布订阅模式）

> Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。
>
> 注意：由于 JavaScript 的限制，Vue **不能检测**数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。（不过只是 vue2 有这个限制，vue2 使用的是 Object.defineProperty 来进行数据劫持；vue3 使用了 **Proxy** 的方式来进行数据劫持，数组和对象的变化也能检测）

![vue-v-model](./img/vue-v-model.png)

### vue 的 Scoped 原理
Vue的作用域样式 Scoped CSS 的实现思路如下：

1.  为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件实例的标识符，我称它为组件实例标识，简称实例标识，记作 InstanceID；
2.  给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 `data-v-实例标识`，示例：`<div data-v-e0f690c0="" >`；
3.  给组件的作用域样式 `<style scoped>` 的每一个选择器的最后一个选择器单元增加一个属性选择器 `原选择器[data-v-实例标识]` ，示例：假设原选择器为 `.cls #id > div`，则更改后的选择器为 `.cls #id > div[data-v-e0f690c0]`；

#### 1.3 特点

1.  将组件的样式的作用范围限制在了组件自身的标签，即：组件内部，包含子组件的根标签，但不包含子组件的除根标签之外的其它标签；所以 组件的css选择器也不能选择到子组件及后代组件的中的元素（子组件的根元素除外）；

    > 因为它给选择器的最后一个选择器单元增加了属性选择器 `[data-v-实例标识]` ，而该属性选择器只能选中当前组件模板中的标签；而对于子组件，只有根元素 即有 能代表子组件的标签属性 `data-v-子实例标识`，又有能代表当前组件（父组件）的 签属性 `data-v-父实例标识`，子组件的其它非根元素，仅有能代表子组件的标签属性 `data-v-子实例标识`；

2.  如果递归组件有后代选择器，则该选择器会打破特性1中所说的子组件限制，从而选中递归子组件的中元素；

    > 原因：假设递归组件A的作用域样式中有选择器有后代选择器 `div p` ，则在每次递归中都会为本次递归创建新的组件实例，同时也会为该实例生成对应的选择器 `div p[data-v-当前递归组件实例的实例标识]`，对于递归组件的除了第一个递归实例之外的所有递归实例来说，虽然 `div p[data-v-当前递归组件实例的实例标识]` 不会选中子组件实例（递归子组件的实例）中的 p 元素（具体原因已在特性1中讲解），但是它会选中当前组件实例中所有的 p 元素，因为 父组件实例（递归父组件的实例）中有匹配的 div 元素；

### vue-router的作用是什么？ 为什么不使用a标签？

> vue-router：动态路由，用于跳转页面，另外vue-router还可以实现页面间传参等其他功能。
> 	
> a标签：
> 	点击a标签从当前页面跳转到另一个页面
> 	通过a标签跳转，页面就会重新加载，相当于重新打开了一个网页
> 	
> router-link：
> 	通过router-link进行跳转不会跳转到新的页面，不会重新渲染，它会选择路由所指的组件进行渲染
> 	
> 总结：
> 	通过a标签和router-link对比，router-link避免了重复渲染，不像a标签一样需要重新渲染减少了DOM性能的损耗