## ES6 基础

### ECMAScript 和 JavaScript 的关系

前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。

## ES6 指的是什么

ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。

## 兼容性

+ babel：针对新语法，不针对新的 api
+ polyfill：用于实现浏览器并不支持的原生API的代码

## 新特性

### let、const

> ES6之前只有全局作用域和函数作用域，没有块级作用域。这带来很多不合理的场景:
>
> 1. 内层变量可能覆盖外层变量
> 2. 用来计数的循环变量泄露为全局变量
>
> 为了加强对变量生命周期的控制，ECMAScript 6 引入了块级作用域。

+ 块级作用域存在于：
  + 函数内部
  + 块中(字符 { 和 } 之间的区域)

+ let、const 共同点：
  + 不进行变量提升
  + 重复声明报错
  + let、const声明的全局变量不会挂在顶层对象下面

+ 临时性死区：在代码块内,使用let、const命令声明变量之前,该变量都是不可用的。这在语法上,称为“*暂时性死区*”(temporal dead zone,简称 TDZ) 。暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

    > ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。

+ ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

  ```javascript
  /* 第一种写法，报错
   * 这种写法由于没有大括号不存在块级作用域，let只能出现在当前作用域的顶层，这个例子中let声明的当前作用域为全局作用域，但它处于if判断的子句里，并不是全局作用域的第一层，而是第二层。
  */
  if (true) let x = 1;
  
  // 第二种写法，不报错
  if (true) {
    let x = 1;
  }
  ```

  