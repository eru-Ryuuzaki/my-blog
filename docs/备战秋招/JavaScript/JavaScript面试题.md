####  为什么0.1+0.2 ! == 0.3，如何让其相等

在开发过程中遇到类似这样的问题：

```js
let n1 = 0.1, n2 = 0.2
console.log(n1 + n2)  // 0.30000000000000004
```

这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：

```js
(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入
```

`toFixed(num)` 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？



计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是`0.0001100110011001100...`（1100循环），0.2的二进制是：`0.00110011001100...`（0011循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？

![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20220807213354.png)

IEEE754 规定，双精度浮点数的有效数字是 52 位，如上图

sign(S): 符号位，0 是正数，1 是负数
exponent(E): 指数位
fraction(F): 有效数字

IEEE754 规定，在计算机内部保存有效数字时，默认第一位总是 1，所以可以舍去，只保留后面的部分。
比如保存 1.01，只存 01，等读取的时候再把第一位 1 加上去，所以 52 位有效数字实际可以存储 53 位。

那 JS 中的最大安全整数是多少呢？
这里的安全 指的是能够 one-by-one 表示的整数，
**也就是说在(-2^53,2^53)范围内，双精度数表示和整数是一对一的，**

反过来说，在这个范围以内，所有的整数都有唯一的浮点数表示，这就叫做安全整数，

什么叫最大安全整数？指的也就是这个常量`Number.MAX_SAFE_INTEGER`

现在考虑，我们看两个数2^53与2^53+1。

- 2^53 我们尝试把它表示成二进制：1 53个0 ，规格化 1.0...00 * 2^53
- 那2^53+1呢？我们尝试把它表示成二进制：1 52个0 1 ,标准化 1.0...01 * 2^53

问题来了，尾数都有53位，但只要52个空！ 它的处理办法是 **忽略第53位** ,因此这两个数在计算机中表示的结果一样！

```js
2**53===2**53+1    //true
```

此时就不安全了。显而易见，在2^53-1之后的数中，只要指数相同，并且尾数前52位相同，则这个两个数数值相同。

所以双精度浮点数可以表示的最大安全整数就是 2^53 - 1。

ps: 为了保证当 S 为 0，且 E 的首位也为 0 的时候不被程序当做无效片段给舍弃，IEEE754 默认 E 的首位为 1。
也就是说，指数位 E 在转化为十进制时，需要减去 1023。
比如 11 位的指数位 E 的值为 10000000001 时，其十进制数字为 1025，但是实际代表的指数为 1025 - 1023 = 2。

一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。



根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：`0.30000000000000004`。

对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了`Number.EPSILON`属性，而它的值就是2-52，只要判断`0.1+0.2-0.3`是否小于`Number.EPSILON`，如果小于，就可以判断为0.1+0.2 ===0.3

```js
function numberepsilon(arg1,arg2){                   
  return Math.abs(arg1 - arg2) < Number.EPSILON;        
}        

console.log(numberepsilon(0.1 + 0.2, 0.3)); // true
```

#### 事件流

事件流是网页元素接收事件的顺序，"DOM2级事件"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。

且当事件处于目标阶段时，事件调用顺序决定于绑定事件的**书写顺序**

#### **事件是如何实现的？**

基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。

比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（EventHandler），也就是「启动对话框的显示」这个动作。

在 Web 端，我们常见的就是 DOM 事件：

DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。

DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件

DOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件

> **为什么没有1级DOM?**
>  DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型

#### **new** **一个函数发生了什么**

构造调用：

+ 创造一个全新的对象

+ 这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象

+ 这个新对象会绑定到函数调用的 this

+ 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象

#### **new** **一个构造函数，如果函数返回** return {} **、** return null **，** return 1 **，** return true **会发生什么情况？**

如果函数返回一个对象，那么new 这个函数调用返回这个函数的返回对象，否则返回 new 创建的新对象

#### symbol有什么用处

可以用来表示一个独一无二的变量防止命名冲突。还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。