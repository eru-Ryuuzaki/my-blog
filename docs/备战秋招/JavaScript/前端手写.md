### JavaScript 

+ `Object.create`

  ```js
  function myObjCreate() {
      
  }
  ```

+ `new`操作符

  过程：

  1. `new` 操作符会返回一个对象，所以我们需要在内部创建一个对象
  2. 这个对象，也就是构造函数中的 `this`，可以访问到挂载在 `this` 上的任意属性
  3. 这个对象可以访问到构造函数原型上的属性，所以需要将对象与构造函数链接起来
  4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

  ```js
  function myNew(constructor, ...args) {
      if (typeof constructor !== 'function') {
          return throw TypeError(`${constructor} is not a constructor`)
      }
      let newObj = Object.create(constructor.prototype);
      let result = constructor.apply(newObj, args);
      const flag = result && (typeof result === 'object' || typeof result === 'function');
      return flag ? result : newObj;
  }
  ```

+ `apply`、`call`、`bind`

  + `apply`

    apply 函数的实现步骤：

    1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
    2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。
    3. 将函数作为上下文对象的一个属性。
    4. 判断参数值是否传入
    5. 使用上下文对象来调用这个方法，并保存返回结果。
    6. 删除刚才新增的属性
    7. 返回结果

    ```js
    Function.prototype.myApply = function(ctx, args) {
        if (typeof this !== 'function') {
            return throw TypeError('非法调用')
        }
        ctx = ctx || windows;
        const fn = Symbol();
        ctx[fn] = this;
        let res = undefined;
        if (args) {
            
        } else {
            res = ctx[fn]();
        }
        delete ctx[fn];
        return res;
    }
    ```

  + `call`

    过程：

    1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
    2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。
    3. 处理传入的参数，截取第一个参数后的所有参数。
    4. 将函数作为上下文对象的一个属性。
    5. 使用上下文对象来调用这个方法，并保存返回结果。
    6. 删除刚才新增的属性。
    7. 返回结果。

    ```js
    Function.prototype.myCall = function(ctx, ...args) {
        if (typeof this !== 'function') {
            return throw TypeError('非法调用')
        }
        ctx = ctx || windows;
        args = args ? args : [];
        const fn = Symbol();
        ctx[fn] = this;
        let res = ctx[fn](...args);
        delete ctx[fn];
        return res;
    }
    ```

  + `bind`

    bind 函数的实现步骤：

    1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
    2. 保存当前函数的引用，获取其余传入参数值。
    3. 创建一个函数返回
    4. 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

    > [冴羽大大的写法](https://juejin.cn/post/6844903476623835149)
    
    ```js
    Function.prototype.myBind = function (context, ...args) {
    
        if (typeof this !== "function") {
          throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
        }
    
        const self = this;
        const fNOP = function () {};
    
        let fbound = function () {
            self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));
        }
    
        fNOP.prototype = this.prototype;
        fbound.prototype = new fNOP();
    
        return fbound;
    
    }
    ```

### 设计模式

+ 发布订阅模式

  ```js
  class EventCenter {
      let handlers = {};
      
  	addEventListener(type, handler) {
          if (!this.handles[type]) {
              this.handles[type] = [];
          }
          this.handles[type].push(handler);
      }
  
  	dispatchEvent(type, params) {
          if (!this.handles[type]) {
              return new Error('该事件未注册');
          }
          this.handlers[type].forEach(handler => handler(...params));
      }
  
  	removeEventListener(typem handler) {
          if (!this.handles[type]) {
              return new Error('该事件无效');
          }
          if (!handler) {
              delete this.handlers[type];
          } else {
              const index = this.handlers[type].findIndex(el => el === handler)
                if (index === -1) {
                  return new Error('无该绑定事件')
                }
                // 移除事件
                this.handlers[type].splice(index, 1)
                if (this.handlers[type].length === 0) {
                  delete this.handlers[type]
                }
          }
      }
  }
  ```

  