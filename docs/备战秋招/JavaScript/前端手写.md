### JavaScript 

+ `Object.create`

  ```js
  function myObjCreate() {
      
  }
  ```

+ `new`操作符

  过程：

  1. `new` 操作符会返回一个对象，所以我们需要在内部创建一个对象
  2. 这个对象，也就是构造函数中的 `this`，可以访问到挂载在 `this` 上的任意属性
  3. 这个对象可以访问到构造函数原型上的属性，所以需要将对象与构造函数链接起来
  4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

  ```js
  function myNew(constructor, ...args) {
      if (typeof constructor !== 'function') {
          return throw TypeError(`${constructor} is not a constructor`)
      }
      let newObj = Object.create(constructor.prototype);
      let result = constructor.apply(newObj, args);
      const flag = result && (typeof result === 'object' || typeof result === 'function');
      return flag ? result : newObj;
  }
  ```

+ `apply`、`call`、`bind`

  + `apply`

    apply 函数的实现步骤：

    1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
    2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。
    3. 将函数作为上下文对象的一个属性。
    4. 判断参数值是否传入
    5. 使用上下文对象来调用这个方法，并保存返回结果。
    6. 删除刚才新增的属性
    7. 返回结果

    ```js
    Function.prototype.myApply = function(ctx, args) {
        if (typeof this !== 'function') {
            return throw TypeError('非法调用')
        }
        ctx = ctx || windows;
        const fn = Symbol();
        ctx[fn] = this;
        let res = undefined;
        if (args) {
            
        } else {
            res = ctx[fn]();
        }
        delete ctx[fn];
        return res;
    }
    ```

  + `call`

    过程：

    1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
    2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。
    3. 处理传入的参数，截取第一个参数后的所有参数。
    4. 将函数作为上下文对象的一个属性。
    5. 使用上下文对象来调用这个方法，并保存返回结果。
    6. 删除刚才新增的属性。
    7. 返回结果。

    ```js
    Function.prototype.myCall = function(ctx, ...args) {
        if (typeof this !== 'function') {
            return throw TypeError('非法调用')
        }
        ctx = ctx || windows;
        args = args ? args : [];
        const fn = Symbol();
        ctx[fn] = this;
        let res = ctx[fn](...args);
        delete ctx[fn];
        return res;
    }
    ```

  + `bind`

    bind 函数的实现步骤：

    1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
    2. 保存当前函数的引用，获取其余传入参数值。
    3. 创建一个函数返回
    4. 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

    > [冴羽大大的写法](https://juejin.cn/post/6844903476623835149)
    
    ```js
    Function.prototype.myBind = function (context, ...args) {
    
        if (typeof this !== "function") {
          throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
        }
    
        const self = this;
        const fNOP = function () {};
    
        let fbound = function () {
            self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));
        }
    
        fNOP.prototype = this.prototype;
        fbound.prototype = new fNOP();
    
        return fbound;
    
    }
    ```

### 设计模式

+ 发布订阅模式

  ```js
  class EventCenter {
      let handlers = {};
      
  	addEventListener(type, handler) {
          if (!this.handles[type]) {
              this.handles[type] = [];
          }
          this.handles[type].push(handler);
      }
  
  	dispatchEvent(type, params) {
          if (!this.handles[type]) {
              return new Error('该事件未注册');
          }
          this.handlers[type].forEach(handler => handler(...params));
      }
  
  	removeEventListener(typem handler) {
          if (!this.handles[type]) {
              return new Error('该事件无效');
          }
          if (!handler) {
              delete this.handlers[type];
          } else {
              const index = this.handlers[type].findIndex(el => el === handler)
                if (index === -1) {
                  return new Error('无该绑定事件')
                }
                // 移除事件
                this.handlers[type].splice(index, 1)
                if (this.handlers[type].length === 0) {
                  delete this.handlers[type]
                }
          }
      }
  	// 待完善
  	once(){}
}
  ```
  
  

### 场景题

+ 继承

  + 原型链继承

    ```js
    function Parent () {
        this.name = 'kevin';
    }
    
    Parent.prototype.getName = function () {
        console.log(this.name);
    }
    
    function Child () {
    
    }
    
    Child.prototype = new Parent();
    
    var child1 = new Child();
    
    console.log(child1.getName()) // kevin
    ```

    > 原型链并非十分完美, 它包含如下两个问题.
    >
    > 问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;
    >
    > 问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数.

  + 借用构造函数(经典继承)

    ```js
    function Parent() {
        this.name = ['Ryuuzaki', 'Camille'];
    }
    function Child() {
        Parent.call(this);
    }
    let child1 = new Child();
    child1.names.push('Eru');
    console.log(child1.names);
    let child2 = new Child();
    console.log(child1.names);
    // > ["Ryuuzaki","Camille","Eru"]
    // > ["Ryuuzaki","Camille"]
    ```

    > 优点：
    >
    > 1. 避免了引用类型的属性被所有实例共享
    >
    > 2. 可以在 Child 中向 Parent 传参
    >
    > 缺点：
    >
    > 1. 方法都在构造函数中定义，每次创建实例都会创建一遍方法。

  + 组合继承

    > 原型链继承和经典继承双剑合璧。

    ```js
    function Parent (name) {
        this.name = name;
        this.colors = ['red', 'blue', 'green'];
    }
    
    Parent.prototype.getName = function () {
        console.log(this.name)
    }
    
    function Child (name, age) {
    
        Parent.call(this, name);
    
        this.age = age;
    
    }
    
    Child.prototype = new Parent();
    
    var child1 = new Child('kevin', '18');
    
    child1.colors.push('black');
    
    console.log(child1.name); // kevin
    console.log(child1.age); // 18
    console.log(child1.colors); // ["red", "blue", "green", "black"]
    
    var child2 = new Child('daisy', '20');
    
    console.log(child2.name); // daisy
    console.log(child2.age); // 20
    console.log(child2.colors); // ["red", "blue", "green"]
    ```

    > 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

  + 原型式继承

    ```js
    function createObj(o) {
        function F(){}
        F.prototype = o;
        return new F();
    }
    var person = {
        name: 'kevin',
        friends: ['daisy', 'kelly']
    }
    
    var person1 = createObj(person);
    var person2 = createObj(person);
    
    person1.name = 'person1';
    console.log(person2.name); // kevin
    
    person1.firends.push('taylor');
    console.log(person2.friends); // ["daisy", "kelly", "taylor"]
    ```

    > 注意：修改`person1.name`的值，`person2.name`的值并未发生改变，并不是因为`person1`和`person2`有独立的 name 值，而是因为`person1.name = 'person1'`，给`person1`添加了 name 值，并非修改了原型上的 name 值。

  + 寄生式继承

    > 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

    ```js
    function createObj (o) {
        let clone = object.create(o);
        clone.sayName = function () {
            console.log('hi');
        }
        return clone;
    }
    ```

    > 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

  + 寄生式组合继承

    > 先借用前面的代码

    ```js
    function Parent (name) {
        this.name = name;
        this.colors = ['red', 'blue', 'green'];
    }
    
    Parent.prototype.getName = function () {
        console.log(this.name)
    }
    
    function Child (name, age) {
        Parent.call(this, name);
        this.age = age;
    }
    
    Child.prototype = new Parent();
    
    var child1 = new Child('kevin', '18');
    
    console.log(child1)
    ```

    组合继承最大的缺点是会调用两次父构造函数。

    一次是设置子类型实例的原型的时候：

    ```js
    Child.prototype = new Parent();
    ```

    一次在创建子类型实例的时候：

    ```js
    var child1 = new Child('kevin', '18');
    ```

    回想下 new 的模拟实现，其实在这句中，我们会执行

    ```js
    Parent.call(this, name);
    ```

    在这里，我们又会调用了一次 Parent 构造函数。

    所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为`colors`，属性值为`['red', 'blue', 'green']`。

    那么我们该如何精益求精，避免这一次重复调用呢？

    如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？

    看看如何实现：

    ```js
    function Parent (name) {
        this.name = name;
        this.colors = ['red', 'blue', 'green'];
    }
    
    Parent.prototype.getName = function () {
        console.log(this.name)
    }
    
    function Child (name, age) {
        Parent.call(this, name);
        this.age = age;
    }
    
    // 关键的三步
    var F = function () {};
    
    F.prototype = Parent.prototype;
    
    Child.prototype = new F();
    
    
    var child1 = new Child('kevin', '18');
    
    console.log(child1);
    ```

    最后我们封装一下这个继承方法：

    ```js
    function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
    }
    
    function prototype(child, parent) {
        var prototype = object(parent.prototype);
        prototype.constructor = child;
        child.prototype = prototype;
    }
    
    // 当我们使用的时候：
    prototype(Child, Parent);
    ```

    > 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。

