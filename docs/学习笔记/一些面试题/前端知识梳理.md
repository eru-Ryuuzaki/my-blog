## ==巧用二八定律，用 20% 的时间去吸收 80% 的知识==

## 知识点查漏补缺列表（给我狠狠地串起来，形成自己的知识体系）

- **H5 + C3**

* [x] 对 HTML 语义化的理解
* [x] src 和 href 的区别
* [x] link 和 import 的区别
* [ ] 左右定宽，中间自适应
  - [ ] 圣杯布局
  - [ ] 双飞翼布局
  - [ ] flex 布局
  - [ ] absolute 布局
  - [ ] 如何清除浮动浮动
  - [ ] BFC
* [x] 伪元素和伪类的区别
* [ ] position

- JS

* [x] 语言特点
* [x] 数据类型
  - [x] 基本数据类型
  - [x] 引用类型
  - [x] 存放位置的区别，为什么这样存
  - [x] 值传递和引用传递
  - [x] 如何判断数据的数据类型
    - [x] 几种方法
    - [x] 各种方法的优缺点
    - [x] typeof null 问题
  - [x] 数据类型转换
    - [x] 显式转换
    - [x] 隐式转换
* [x] 闭包
  - [x] 节流防抖（手写）
  - [ ] 模块化
    - [ ] CommonJS、AMD、CMD 以及 ES6
  - [ ] 设计模式（单例模式）
  - [ ] computed 和 watched
  - [x] 内存泄漏
  - [x] 网页内存使用情况
  - [x] 垃圾回收机制
    - [x] 标记计数和引用计数
    - [x] 内存碎片
      - [x] 新老生代
      - [ ] 更加深入的理解
  - [ ] 作用域
* [ ] 原型、原型链
* [ ] 继承
* [ ] 模块化
* [ ] ES6+ 新特性
  - [x] promise
    - [x] 同步异步
    - [ ] 事件循环
      - [ ] 宏任务微任务
      - [ ] 为什么分宏任务微任务
  - [x] generator
  - [x] async/await
  - [x] let, const
  - [ ] map/weakmap、set/weakset
  - [ ] 数组新增拓展
  - [ ] 对象新增拓展
  - [ ] 函数新增拓展
    - [ ] 箭头函数
  - [ ] proxy
  - [ ] module
  - [ ] decorator
* [ ] 数组和字符串的常见方法
  - [ ] 数组
    - [ ] 增：push、unshift、splice、concat
    - [ ] 删：pop、shift、splice、slice
    - [ ] 改：splice
    - [ ] 查：indexOf、includes、find
    - [ ] 排序：reverse、sort
    - [ ] 转换：join
    - [ ] 迭代：some、every、foreach、filter、map、reduce

- **Vue**

* [x] 对 Vue 的理解（通俗易懂版）
* [ ] SPA 与 MPA 的优劣
* [ ] Vue 生命周期
* [ ] 响应式原理
* [ ] Vue 双向绑定原理
* [ ] diff 算法
* [ ] Vue-router
  - [ ] 原理
  - [ ] history 和 hash 模式的区别
  - [ ] 源码阅读

- 前端工程化

* [ ] 移动端适配（多设备兼容）
  - [ ]
* [ ] 单元测试
* [ ] 代码检测工具
* [ ] sourcemap
* [ ] 从零搭建前端系统，需要做哪些设计，选型

- **前端工程化**

* [ ] webpack
  - [ ] loader 和 plugin 的区别

- **计算机网络**

* [x] 从输入一个 URL 到页面渲染完毕的过程
  - [ ] DNS 解析过程
  - [ ] tcp 三次握手、四次挥手
  - [ ] https 相关
  - [ ] 浏览器渲染过程
* [x] 请求方法有哪些以及应用场景
  - [x] get 和 post 请求方法的区别
  - [x] put 和 post 的区别
* [x] 状态码
  - [x] 永久重定向和暂时重定向
* [x] 缓存
  - [x] 浏览器本地缓存
  - [x] http 缓存
    - [x] 协商缓存和强缓存
    - [x] 过程
    - [x] 使用场景
  - [ ] 常见头部
  - [ ] 浏览器缓存
* [ ] http、https
  - [ ] http1.0、http1.1、http2.0、http3.0
  - [ ] 怎么提供安全保障的
* [ ] tcp 三次握手、四次挥手

- **算法与数据结构**

* [ ] 了解一下红黑树

- **知识广度**

* [ ] 前端安全
  - [ ] 跨域
    - [x] 同源策略
  - [ ] 鉴权
  - [ ] ddos
  - [x] csrf
    - [x] origin 和 referer 的区别
  - [ ] xss
  - [ ] iframe 安全问题
* [ ] 设计模式
* [ ] 数据库
* [ ] 操作系统
* [ ] Java
* [ ] [array.sort()传入一个随机比较函数得到的数组并不是绝对乱序的](https://juejin.cn/post/6844903473981423630)

### H5 + C3

#### ==对 HTML 语义化的理解==

- 用正确的标签做正确的事情！
- _html_ 语义化就是让页面的内容结构化，**便于对浏览器、搜索引擎解析；**
- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。
- **便于阅读维护理解**

#### ==src 和 href 的区别==

src 和 href 都是**用来引用外部的资源**，它们的区别如下：

- **src：** 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在页面底部。
- **href：** 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 a、link 等标签上。

#### ==link 和 import 的区别==

- link 是 HTML 标签，除了加载 CSS 外，还可以定义 RSS、rel 属性等；@import 是 CSS 语法规则，只能导入样式表。
- link 标签在页面加载时同时加载 CSS 文件；@import 在页面加载完毕后才加载 CSS 文件。
- link 标签没有兼容性问题；@import 只有 IE5 及以上版本才支持。

#### ==左右定宽，中间自适应==

> **圣杯布局和双飞翼布局都是三栏布局的实现方式。圣杯布局是在父元素上设置了 padding-left 和 padding-right，在给左右两边的内容设置 position 为 relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼布局则是在中间这个 div 的外层又套了一个 div 来放置内容，在给这个中间的 div 设置 margin-left 和 margin-right。**具体实现可以参考以下链接。
>
> 源: 与必应的对话， 2023/3/28(1) 圣杯布局和双飞翼布局的区别*圣杯布局和双飞翼布局 .... https://blog.csdn.net/weixin_43974265/article/details/115427185 访问时间 2023/3/28.
> (2) CSS 系列之双飞翼布局与圣杯布局 - 掘金. https://juejin.cn/post/7141961493230125063 访问时间 2023/3/28.
> (3) 圣杯布局、双飞翼布局具体实现原理和实现方法*圣杯 .... https://blog.csdn.net/qq_41024904/article/details/103673187 访问时间 2023/3/28.
> (4) CSS 之圣杯布局与双飞翼布局 - 掘金. https://juejin.cn/post/6973562604581027853 访问时间 2023/3/28.
> (5) 【CSS】圣杯布局和双飞翼布局（包括完整代码）\_圣杯 .... https://blog.csdn.net/weixin_42678675/article/details/118542011 访问时间 2023/3/28.

- 圣杯布局

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <style>
        .left {
          /* 固定大小 */
          width: 100px;
          height: 100px;

          /* 左浮动 */
          float: left;

          /* 左区域上去 */
          margin-left: -100%;
          position: relative;
          left: -100px;
        }

        .center {
          /* 自适应 */
          height: 100px;
          width: 100%;

          /* 左浮动 */
          float: left;
        }

        .right {
          /* 固定大小 */
          width: 200px;
          height: 100px;

          /* 左浮动 */
          float: left;

          /* 右区域上去 */
          margin-left: -200px;
          position: relative;
          left: 200px;
        }

        /* 伪元素清除浮动 */
        .clearfix::after {
          content: "";
          clear: both;
          display: block;
        }

        /* 两侧留白 */
        .wrapper {
          /* padding：上 右 下 左 */
          padding: 0px 200px 0px 100px;
        }
      </style>

      <header style="background-color: green;">圣杯布局 头部</header>
      <main class=" clearfix wrapper">
        <div class="center" style="background-color:red ;">主区域</div>
        <div class="left" style="background-color: yellow;">左区域</div>
        <div class="right" style="background-color: pink;">右区域</div>
      </main>
      <footer style="background-color: green;">底部</footer>
    </body>
  </html>
  ```

#### ==伪类和伪元素的区别==

- 伪类是用于选择处于特定状态的元素，比如:hover, :active 等。

- 伪元素是用于在文档中插入虚构的元素，比如::before, ::after 等。

- 伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。

- 语法上，CSS3 推荐使用单冒号表示伪类，双冒号表示伪元素。

  > 但是为了兼容旧的浏览器，CSS3 也允许使用单冒号表示已经存在的伪元素，比如:before, :after 等

- 一个选择器上可以有多个伪类，但是不能有多个伪元素。伪类可以在选择器的任何位置使用，而伪元素只能在选择器的最后一个简单选择器之后添加。

### JavaScript

#### ==语言特点==

JS（JavaScript）是一种解释性的脚本语言，主要用来向 HTML 页面添加交互行为。JS 的一些特性有：基于对象、弱类型、事件驱动、依赖于浏览器（现在已经不是了吧）。JS 遵循了 Java 的表达式语法，命名规范以及基础流程控制，但是没有 Java 的静态类型和强类型检查特性。（我觉得还可以加个单线程）

> 解释性的脚本语言：解释性的脚本语言是一种不需要编译成二进制代码，而是在运行时由解释器逐行执行的编程语言。例如，JavaScript、Python、Perl 等都是解释性的脚本语言。解释性的脚本语言通常具有高层次的抽象、动态类型、易于嵌入和扩展等特点。
>
> 事件驱动：事件驱动是一种编程模式，它的核心思想是当某些事件发生时，触发相应的操作或函数。事件可以是用户的输入、系统的状态变化、消息的到达等。事件驱动可以提高系统的响应性、解耦性和可扩展性。

#### ==数据类型==

- 分为基本数据类型和引用数据类型

  - 基本数据类型：

    - null

    - undefined

    - symbol

      > - 用作对象中的键，可以避免属性名冲突或被覆盖。
      >
      > - 用于模拟私有属性，因为 Symbol 值不能被外部访问或修改。
      >
      > - 用于定义内置对象的一些特殊行为，如迭代器、异步迭代器等。
      >
      >   > 通过 Symbol 访问的目的是为了实现数据和操作的封装，防止命名冲突或被外部修改。
      >   > 设计思想是基于面向对象的原则，将数据和功能组合成一个类，只对外提供公共访问方式，隐藏内部实现细节。
      >   > 这样可以提高代码的模块性、可维护性和安全性，符合人们的思考习惯。

    - string

    - boolean

    - number

    - bigInt（也可以不说吧，怕埋坑）

  - 引用数据类型:
    - object
      - Array
      - RegExp
      - Date
      - Math
      - Function

- 存储的位置

  - 原始数据类型直接存储在栈（stack）中的简单数据段
    - 占据空间小、大小固定
    - 属于被频繁使用数据，所以放入栈中存储；
  - 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。
    - 如果存储在栈中，将会影响程序运行的性能；
    - **引用数据类型在栈中存储了引用地址，该引用地址指向堆中该实体的起始地址。**
    - 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

  小结：

  - 声明变量时不同的内存地址分配：

    - 简单类型的值存放在栈中，在栈中存放的是对应的值
    - 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址

  - 不同的类型数据导致赋值变量时的不同：

    - 简单类型赋值，是生成相同的值，两个对象对应不同的地址
    - 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象

    ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230322001838.png)

  * 为什么读取栈的数据比读取堆的快？

    栈的特点是有限的空间，（进入上下文的时候就分配了？），数据的存储和读取速度较快，因为它们是线性排列的，CPU 可以直接通过指针访问到栈中的数据。

    相比之下，堆是一种动态分配的内存空间，用于存储程序运行时动态创建的对象，例如通过 new 关键字创建的对象、数组等。堆的特点是空间不限，数据的存储和读取速度较慢，因为数据的存储位置是动态分配的，需要通过指针间接访问，增加了访问的时间成本。

    因此，栈中的数据访问速度比堆中的数据访问速度更快，但栈的空间有限，只适合存储局部变量和函数参数等数据，而堆则适合存储动态创建的对象和数据结构。

  * ==值传递和引用传递==

    值传递和引用传递的区别主要在于函数参数的传递方式。
    值传递是指在函数中传递的是一个数值，也就是基本数据类型（string, number, boolean）。这种情况下，函数内部对参数的修改不会影响到外部变量的值。
    引用传递是指在函数中传递的是一个对象，也就是引用数据类型（array, object, function）。这种情况下，函数内部对参数的修改会影响到外部变量的值，因为它们指向同一个内存地址。

- ==如何判断数据的数据类型==

  - typeof

    缺点：可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的无法判断

    > 为什么 typeof null === object ?
    >
    > typeof null \=== object 的原因是一个历史遗留的 bug。
    > 在 JavaScript 的最初版本中，使用了 32 位系统，每个值都由一个类型标签和一个数据值组成。类型标签占用 1-3 位，数据值占用剩余的位数。
    > 对象的类型标签是 0，而 null 是用 NULL 指针（在大多数平台上是 0x00）来表示的。因此，null 也用 0 作为类型标签，所以 typeof 返回了"object"。
    > 后来有人提出了修复这个 bug 的方案，但被拒绝了。如果修复了这个 bug，那么 typeof null === "null"就会成为真。

  - instanceof

    缺点：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型（基本数据类型没有原型）

  - Object.prototype.toString.call()

    Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。

    但是在写判断条件的时候一定要注意，使用这个方法最后返回统一字符串格式为 "[object Xxx]" ，而这里字符串里面的 "Xxx" ，**第一个首字母要大写**（注意：使用 typeof 返回的是小写），这里需要多加留意。

  > ==判断一个对象是否为空对象==
  >
  > - JSON.stringify(data) === '{}'
  >
  > - Object.keys(data).length
  >
  > - Object.values(data).length
  >
  > - ~~for..in~~（原型上的属性呢也会遍历，所以这种其实不行吧）
  >
  >   ```js
  >   let data = {};
  >   let data1 = {
  >     name: "大帅哥",
  >     age: "18",
  >   };
  >   let _fn = (obj) => {
  >     for (let key in obj) {
  >       return false;
  >     }
  >     return true;
  >   };
  >   console.log(_fn(data)); //true
  >   console.log(_fn(data1)); //false
  >   ```
  >
  > - {}.hasOwnProperty.call(obj,key)
  >
  >   ```js
  >   let data = {};
  >   let data1 = {
  >     name: "大帅哥",
  >     age: "18",
  >   };
  >   let _fn = (obj) => {
  >     for (let _key in obj) {
  >       if (obj.hasOwnProperty(_key)) {
  >         return false;
  >       }
  >     }
  >     return true;
  >   };
  >   console.log(_fn(data)); //true
  >   console.log(_fn(data1)); //false
  >   ```
  >
  > - Object.getOwnPropertyNames()

- ==数据类型转换==

  - 强制转换

    - Number()、parseInt()、parseFloat()、toString()、String()、Boolean() 直接转换成相对应的类型

    - 规则：

      ###### Number() 方法的强制类型转换

      - 如果是布尔值，true 和 false 分别被转换为 1 和 0；
      - 如果是数字，返回自身；
      - **如果是 null，返回 0；**
      - **如果是 undefined，返回 NaN；**
      - 如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；
      - **如果是 Symbol，抛出错误；**
      - 如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值。

      ###### Boolean() 方法的强制转换规则

      这个方法的规则是：除了 undefined、 null、 false、 ''、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。(**注意：空数组转换是 true**)

  - 隐式转换

    **凡是通过逻辑运算符 (&&、 ||、 !)、运算符 (+、-、\*、/)、关系操作符 (>、 <、 <= 、>=)、相等运算符 (==) 或者 if/while 条件的操作，如果遇到两个数据类型不一样的情况，都会出现隐式类型转换。**

    - ###### '==' 的隐式类型转换规则

      - 如果类型相同，无须进行类型转换；
      - 如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；
      - 如果其中一个是 Symbol 类型，那么返回 false；
      - 两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；
      - 如果一个操作值是 boolean，那么转换成 number；
      - 如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 [ToPrimitive] 函数(应该是这个先吧，我自己加上去的)/valueOf/toString 方法进行转换）。

    - ###### '+' 的隐式类型转换规则

      '+' 号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当 '+' 号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。

      除了上述比较常规的情况外，还有一些特殊的规则，如下所示。

      - 如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级（下一讲会专门介绍），然后再进行拼接。
      - 如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。
      - 如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接。

      整体来看，如果数据中有字符串，JavaScript 类型转换还是更倾向于转换成字符串，因为第三条规则中可以看到，在字符串和数字相加的过程中最后返回的还是字符串，这里需要关注一下。

    - ###### Object 的转换规则

      对象转换的规则，会先调用内置的 [ToPrimitive] 函数，其规则逻辑如下：

      - 如果部署了 Symbol.toPrimitive 方法，优先调用再返回；
      - 调用 valueOf()，如果转换为基础类型，则返回；
      - 调用 toString()，如果转换为基础类型，则返回；
      - 如果都没有返回基础类型，会报错。

#### ==闭包==

- 闭包是什么？

  > 闭包是一个可以访问到外层函数里面的变量的函数。也可以说，闭包是一个函数以及其捆绑的周边环境状态（**lexical environment**，**词法环境**）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。闭包是由函数及其相关的引用环境组合而成的实体。

- 闭包的作用以及使用场景

  > - 作用
  >   - 可以用来定义私有变量或者私有方法，避免变量污染（模块化）
  >   - 延长变量的生命周期，变量被内层函数所引用所以并不会被垃圾回收清除
  >   - 实现函数式编程的高阶函数（？）
  >   - 做一些缓存处理，例如单例模式、computed
  > - 使用场景
  >
  >   - 节流防抖
  >
  >     ```js
  >     // throttle
  >     function throttle(fn, delay) {
  >       let timer = false;
  >       return function (...args) {
  >         if (timer) return;
  >         timer = true;
  >         timer = setTimeout(() => {
  >           timer = false;
  >         }, delay);
  >         fn.apply(this, args);
  >       };
  >     }
  >
  >     // debounce
  >     // 2023-3-16 写错了
  >     /*
  >     function debounce(fn, delay) {
  >         let timer = null;
  >         return function(...args) {
  >             if (timer) return;
  >             fn.apply(this, args);
  >             timer = setTimeout(() => {
  >                 timer = null; 
  >             }, delay);
  >         }
  >     }
  >     */
  >     ```
  >
  >   - 模块化
  >
  >   - 单例模式、computed(这里可能会被往设计模式那边或者 computed 实现原理那边去问了)

- 闭包的弊端

  > - 使用不当会导致内存泄漏。闭包会导致一些变量一直存在于内存中，即使它们已经不再需要。
  > - 性能问题。过度使用闭包，会使应用的内存一直得不到释放，增加内存使用量，堆栈内存变大，降低程序的性能和稳定性。同时由于闭包涉及到变量的作用域链查找，因此在访问闭包内部的变量时会比访问局部变量或全局变量更耗费时间。

- ==如何查看网页的内存泄漏情况（内存情况）？==

  > 内存泄漏是指在应用程序中一块内存没有被正确释放或回收
  >
  > - 使用 Chrome DevTools：在 Chrome 浏览器中，可以使用开发者工具（DevTools）来检查网页是否存在内存泄漏。打开 Chrome DevTools，切换到“Memory”选项卡，然后进行堆快照（Heap Snapshot），查看对象的引用关系，以及是否存在被遗忘的对象。
  >
  >   > 以下是使用 Heap Snapshot 来分析内存泄漏的步骤：
  >   >
  >   > 1. 打开 Chrome 开发者工具，在 Memory 面板中选择“Take Heap Snapshot”（或者直接使用快捷键 Ctrl + Shift + E）来记录一个初始状态的 Heap Snapshot。
  >   > 2. 执行一些操作，让代码运行一段时间，然后再次记录一个 Heap Snapshot。这个快照应该显示出之前快照中不存在的新对象，以及之前存在但现在已经不再使用的对象。
  >   > 3. 在两个 Heap Snapshot 之间，找到那些被创建但从未被释放的对象。这些对象很可能是内存泄漏的原因。可以使用“Comparison”选项卡来查看两个 Heap Snapshot 之间对象的差异。
  >   > 4. 确认哪些对象没有被正确释放。这些对象可能是事件监听器、定时器或未被清除的 DOM 元素等。使用“Retainers”选项卡来查找这些对象。
  >   > 5. 根据上述信息分析代码并修复内存泄漏问题。可以使用代码审查和调试器来找到问题所在。
  >   > 6. 修复问题后，再次运行应用程序并记录 Heap Snapshot，确保内存泄漏已被解决。
  >   >
  >   > 需要注意的是，Heap Snapshot 分析是一种有限的工具，可能会遇到一些限制。例如，它可能无法检测到循环引用等高级内存管理问题。因此，在使用 Heap Snapshot 分析内存泄漏时，需要结合其他工具和技术来进行综合诊断和修复。
  >
  > - 观察系统资源：如果网页存在内存泄漏，可能会导致浏览器消耗大量的系统资源，例如 CPU 占用率和内存占用率等。因此，可以使用系统监视器或任务管理器等工具来观察系统资源的变化，判断是否存在内存泄漏问题。
  >
  > - 其他的一些专业工具
  >
  > 一些可能会导致内存泄漏的情况
  >
  > - 未正确清除的事件监听器
  > - 未正确清除的事件定时器
  > - 未被清除的 DOM 元素
  > - 循环引用

#### ==原型、原型链==

原型和原型链是 JavaScript 中的重要概念，也是面试中常被问到的问题。对于原型，可以这样回答：原型是 JavaScript 中的一个对象，它是由构造函数创建的，构造函数的 prototype 属性指向了原型对象。而原型链是由原型对象构成的链式结构，它是由每个对象的**proto**属性指向其原型对象，最终指向 Object.prototype。如果面试官进一步问到原型链的作用，可以回答：原型链的作用是实现继承，它可以让一个对象继承另一个对象的属性和方法。如果面试官进一步问到原型链的缺点，可以回答：原型链的缺点是容易造成属性共享和属性覆盖的问题，因为多个对象的**proto**属性指向同一个原型对象，所以它们共享了原型对象中的属性和方法，如果一个对象修改了原型对象中的属性或方法，那么其他对象也会受到影响。

#### ==垃圾回收机制==

- 什么是垃圾回收机制（GC）？

  > `GC` 即 `Garbage Collection` ，程序工作过程中会产生很多 `垃圾`，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 `GC` 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，`GC` 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 `垃圾回收机制` 了
  >
  > 当然也不是所有语言都有 `GC`，一般的高级语言里面会自带 `GC`，比如 `Java、Python、JavaScript` 等，也有无 `GC` 的语言，比如 `C、C++` 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦

- 垃圾是怎样产生的？

  > 垃圾产生的主要原因是内存中存在不再被引用的对象或变量，这些对象或变量无法被访问或使用（不可达），但它们仍然占用内存空间。垃圾收集器会定期执行垃圾回收操作，将这些垃圾对象从内存中清除，以释放内存空间供其他对象或变量使用。
  >
  > 内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。

- 垃圾回收是怎样进行的？

> **标记清除算法**
>
> - 标记过程
>
>   当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
>
> - **策略**
>
>   标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 `JavaScript引擎` 在运行垃圾回收的频率上有所差异。
>
>   给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。
>
> - 大致整体过程：
>
>   - 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
>   - 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
>   - 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
>   - 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收
>
> - 优缺点
>
> > 优点
> >
> > 标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0 和 1）就可以为其标记，非常简单，适用于短生命周期对象的垃圾回收。
> >
> > 缺点
> >
> > 需要遍历所有的对象，对于大量对象时性能较差。标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
>
> - **内存碎片**
>
>   > ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230316153917.png)
>   >
>   > 内存分配策略：
>   >
>   > - `First-fit`，找到大于等于 `size` 的块立即返回
>   > - `Best-fit`，遍历整个空闲列表，返回大于等于 `size` 的最小分块
>   > - `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 `size` 大小，并将该部分返回
>   > - 这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 `First-fit` 和 `Best-fit` 来说，考虑到分配的速度和效率 `First-fit` 是更为明智的选择
>   >
>   > 综上所述，标记清除算法或者说策略就有两个很明显的缺点
>   >
>   > - **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
>   > - **分配速度慢**，因为即便是使用 `First-fit` 策略，其操作仍是一个 `O(n)` 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
>   >
>   > **PS：标记清除算法的缺点补充**
>   >
>   > 归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了
>   >
>   > 而 **标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）
>   >
>   > ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230316155208.png)
>
> **引用计数算法**
>
> - 策略
>
>   引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下
>
> - **大致过程**
>
>   它的策略是跟踪记录每个变量值被使用的次数
>
>   - 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
>   - 如果同一个值又被赋给另一个变量，那么引用数加 1
>   - 如果该变量的值被其他的值覆盖了，则引用次数减 1
>   - 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存
>
> 在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子
>
> ```js
> function test() {
>   let A = new Object();
>   let B = new Object();
>
>   A.b = B;
>   B.a = A;
> }
> ```
>
> 如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 `test` 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放
>
> 我们再**用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉**，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，**这也是后来放弃引用计数，使用标记清除的原因之一**
>
> - 优缺点
>
>   > 优点
>   >
>   > 引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，**也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾**
>   >
>   > 而**标记清除算法需要每隔一段时间进行一次**，那在应用程序（JS 脚本）运行过程中线程就必须要暂停去执行一段时间的 `GC`，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了
>   >
>   > 缺点
>   >
>   > 引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的

- V8 引擎对垃圾回收进行了哪些优化？

  **分代式垃圾回收**

  试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了

  **新老生代**

  V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

  新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大

  对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了

  **新生代垃圾回收**

  新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收，在 `Scavenge算法` 的具体实现中，主要采用了一种复制式的方法即 `Cheney算法` ，我们细细道来

  `Cheney算法` 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 `使用区`，一个是处于闲置状态的空间我们称之为 `空闲区`，如下图所示

  ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230316164723.png)

  新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作

  当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区

  当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

  另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

  **老生代垃圾回收**

  相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了

  首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象

  清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉

  前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间

  [更多优化可以看这篇文章](https://juejin.cn/post/6981588276356317214)

#### ==作用域==

#### ==ES6+==

- **promise**

  - 诞生背景——异步编程

    - 什么是同步和异步

      所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。

      所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。

    - 为什么 JS 需要异步编程

      我们都知道 JavaScript 是单线程的，如果 JS 都是同步代码执行意味着什么呢？这样可能会造成阻塞，如果当前我们有一段代码需要执行时，如果使用同步的方式，那么就会阻塞后面的代码执行；而如果使用异步则不会阻塞，我们不需要等待异步代码执行的返回结果，可以继续执行该异步任务之后的代码逻辑。因此在 JS 编程中，会大量使用异步来进行编程

    我们在日常开发中都用过的 JS 异步编程的方式总结起来无外乎有这几种：回调函数、事件监听、Promise、Generator、async/await，这几种 JS 的编程方式都是异步编程。**回调函数方式是最早的 JS 异步编程的方式**，后随着 ES 标准的发展，Promise、Generator 和 async/await 接连出现。但是使用回调函数来实现存在一个很常见的问题，那就是**回调地狱**。

    > 回调地狱主要操作两个问题：
    >
    > 1. 多层嵌套的问题；
    > 2. 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。如果是 setTimeout 那种回调，**回调函数的执行栈与原函数分离开，导致外部无法抓住异常。**

  - ==对 promise 的理解==

    Promise 是一种解决异步编程的方案，它可以让我们更好地处理异步操作，避免了回调地狱的问题。Promise 对象代表一个异步操作，有三种状态：进行中、已成功和已失败。我们可以通过 then 方法来获取异步操作的结果，**then 方法返回的是一个新的 Promise 实例，因此可以采用链式写法。**一旦状态改变（从 pending 变为 fulfilled 和从 pending 变为 rejected），就不会再变，任何时候都可以得到这个结果。

  - promise 优缺点

    优点

    1. Promise 分离了异步数据获取和业务逻辑，有利于代码复用。
    2. 可以采用链式写法，使代码变得更加简洁易懂。
    3. Promise 可以解决回调地狱问题，使代码更加清晰易懂。
    4. Promise 可以很好地处理异步操作，避免了回调函数的嵌套问题。
    5. 更好地进行错误捕获

    缺点

    1. 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。

    2. 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。

       > Promise 内部确实可以处理错误，但是如果没有设置回调函数来处理这个错误，那么这个错误就会被忽略掉，不会被外部捕获到。这会导致程序的健壮性变差

    3. 当处于 pending 状态时，无法得知当前处于哪一个状态，是刚刚开始还是刚刚结束。

    - 在这里介绍一下==事件循环==
      - 为什么分宏任务和微任务?
        - 微任务的出现使得在宏任务执行完到浏览器渲染之前可以插入一些简短的函数，在没有其他脚本干扰的情况下运行，并且在用户代理有机会对该函数带来的行为做出反应之前运行。
        - 微任务可以保证一些异步操作（如 Promise）能够尽快地得到处理和响应，而不用等待下一个宏任务开始。

- ##### Generator

  - 介绍

    Generator 也是一种异步编程解决方案，**它最大的特点就是可以交出函数的执行权**，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注。Generator 函数一般配合 yield 使用，Generator 函数最后返回的是迭代器。

- ##### async/await

  - 介绍

    ES6 之后 ES7 中又提出了新的异步解决方案：async/await，async 是 Generator 函数的语法糖，async/await 的优点是代码清晰（不像使用 Promise 的时候需要写很多 then 的方法链），可以处理回调地狱的问题。async/await 写起来使得 JS 的异步代码看起来像同步代码，其实异步编程发展的目标就是让异步逻辑的代码看起来像同步一样容易理解。

  > 将`promise`、`Generator`、`async/await`进行比较：
  >
  > - `promise`和`async/await`是专门用于处理异步操作的
  >
  > - `Generator`并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署`Interator`接口...）
  >
  >   > 生成器是一种特殊的迭代器，它不需要像普通迭代器一样实现**iter**()和**next**()方法，而是使用 yield 语句返回值。**生成器可以在迭代过程中动态生成值，而不是一次性生成所有值。**因此，当需要处理大量数据时，**使用生成器可以节省内存空间**。此外，生成器还可以用于异步编程，因为它们可以在迭代过程中暂停和恢复。
  >
  > - `promise`编写代码相比`Generator`、`async`更为复杂化，且可读性也稍差
  >
  > - `Generator`、`async`需要与`promise`对象搭配处理异步情况
  >
  > - `async`实质是`Generator`的语法糖，相当于会自动执行`Generator`函数
  >
  > - `async`使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案

- **let、const**（主要讨论和 var 的区别）

  > 在 ES5 中，顶层对象的属性和全局变量是等价的，用`var`声明的变量既是全局变量，也是顶层变量
  >
  > 注意：顶层对象，在浏览器环境指的是`window`对象，在 `Node` 指的是`global`对象

  - 变量提升

    var 声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined
    let 和 const 不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错

  - 暂时性死区

    `var`不存在暂时性死区

    `let`和`const`存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量

  - 块级作用域

    `var`不存在块级作用域

    `let`和`const`存在块级作用域

  - 重复声明

    `var`允许重复声明变量

    `let`和`const`在同一作用域不允许重复声明变量

  - 修改声明的变量

    `var`和`let`可以

    `const`声明一个只读的常量。一旦声明，常量的值就不能改变

  - 使用

    能用`const`的情况尽量使用`const`，其他情况下大多数使用`let`，避免使用`var`

    ###

### Vue

#### ==你是怎么理解 Vue 的？通俗易懂地讲一下==

Vue.js（/vjuː/，或简称为 Vue）是一个**用于创建用户界面的开源 JavaScript 框架**，也是**一个创建单页应用的 Web 应用框架**。

Vue 是一套用于构建用户界面的**渐进式 MVVM 框架**。那怎么理解渐进式呢？渐进式含义：强制主张最少。

Vue.js 包含了声明式渲染、组件化系统、客户端路由、大规模状态管理、构建工具、数据持久化、跨平台支持等，但**在实际开发中，并没有强制要求开发者之后某一特定功能，而是根据需求逐渐扩展**。

Vue 所**关注的核心是 MVC 模式中的视图层**，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互。

Vue.js 的核心库只关心视图渲染，且**由于渐进式的特性，Vue.js 便于与第三方库或既有项目整合**。Vue.js 实现了一套声明式渲染引擎，并在 runtime 或者预编译时将声明式的模板编译成渲染函数，挂载在观察者 Watcher 中，在渲染函数中（touch），响应式系统使用响应式数据的 getter 方法对观察者进行依赖收集（Collect as Dependency），使用响应式数据的 setter 方法通知（notify）所有观察者进行更新，此时观察者 Watcher 会触发组件的渲染函数（Trigger re-render），组件执行的 render 函数，生成一个新的 Virtual DOM Tree，此时 Vue 会对新老 Virtual DOM Tree 进行 Diff，查找出需要操作的真实 DOM 并对其进行更新。

Vue 的核心特性有：

- 采用了 MVVM(Model-View-ViewModel)的软件架构设计模式，实现了数据和视图的双向绑定，让我们可以专注于业务逻辑，而不用操作 DOM。
- 提供了指令、过滤器、插槽、混入等功能，增强了模板的表现力和灵活性。
- 支持组件化开发，可以把复杂的页面拆分成可复用的组件，提高代码的可维护性和复用性。
- 采用虚拟 DOM 和 diff 算法，优化了渲染性能，只更新变化的部分。
- 支持服务端渲染、单文件组件、状态管理等高级特性，适应不同规模和场景的项目需求。

#### ==MVC 和 MVVC 的区别==

**它们之间的区别主要在于它们如何分离视图（View）和数据（Model）之间的交互以及如何管理业务逻辑（Presenter 或 ViewModel）。**

MVC 即模型、视图、控制器（Model View Controller）

> 简单来说就是通过 controller 的控制去操作 model 层的数据，并且返回给 view 层展示。**controller**在这里执行的的就是别墅里面的“**管家**”的作用。

- View 接受用户交互请求
- View 将请求转交给 Controller 处理
- Controller 操作 Model 进行数据更新保存
- 数据更新保存之后，Model 会通知 View 更新
- View 更新变化数据使用户得到反馈

MVVM 即模型、视图、视图模型（Model-View-ViewModel），**ViewModel**是 MVVM 这栋别墅的“**管家**”

- View 接收用户交互请求
- View 将请求转交给 ViewModel
- ViewModel 操作 Model 数据更新
- Model 更新完数据，通知 ViewModel 数据发生变化
- ViewModel 更新 View 数据

> MVVM 设计模式是自动化的，vue 就是采取了这种设计模式，真正把数据和视图分离开的是 MVVM 模式，并不是 MVC，因为 controller 当中有大量手工的 DOM 操作，只要界面改变，controller 中的代码必须要更改（jquery），比如你可以想象一下，你页面当中元素的位置变了，你的选择器是不是肯定要变，选择器就写在 DOM 操作里面，这就是 MVC 和 MVVM 两种设计模式的区别。

```js
// MVC
// Model
var data = {name: 'Tom', age: 18};
// View
var view = document.getElementById('view');
view.innerHTML = data.name + ' is ' + data.age + ' years old.';
// Controller
var button = document.getElementById('button');
button.onclick = function() {
  data.age++; view.innerHTML = data.name + ' is ' + data.age + ' years old.';
};

// MVP
// Model
var data = {name: ‘Tom’, age: 18};
// View
var view = document.getElementById('view');
function render(data) {
  view.innerHTML = data.name + ' is ' + data.age + ' years old.';
}
render(data);
// Presenter
var button = document.getElementById('button');
button.onclick = function() {
    data.age++; render(data);
};

// MVVM
// Model
var data = {name: 'Tom', age: 18};
// View
var view = document.getElementById('view');
view.innerHTML = '{{name}} is {{age}} years old.';
// ViewModel
var vm = new Vue({ el: '#view', data: data, });
var button = document.getElementById('button');
button.onclick = function() { vm.age++; };
```

[可以看一下这个视频方便理解](https://www.bilibili.com/video/BV1Ji4y1U7Y1/?spm_id_from=333.337.search-card.all.click&vd_source=a4fc242d78932c3766e19f28fae791f7)

#### ==Vue 和 React 的区别==

#### ==vue2 和 vue3 的区别==

#### ==响应式原理==

#### ==Vue 双向绑定原理==

### 计算机网络

#### ==对 http 的理解==

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

#### ==状态码==

状态码 原因 说明 100-199 信息响应
100 Continue 已收到请求，客户端应继续
101 Switching Protocol 响应客户端 Upgrade 列出协议，服务端正在切换协议
102 Processing 服务端正在处理请求，无响应可用
103 Early Hints 与 Link 一起使用，客户端应在服务端继续响应前开始预加载资源
200-299 成功响应
**200 OK 请求成功**，常见于 GET HEAD POST TRACE
201 Created 请求成功，新资源已创建，常见于 POST PUT
202 Accepted 请求已收到，但未响应
203 Non-Authoritative Information 响应经过了代理服务器修改
204 No Content 请求已处理，无返回，客户端不更新视图
205 Reset Content 请求已处理，无返回，客户端应更新视图
**206 Partial Content 请求已处理，返回部分内容，常见于视频点播、分段下载、断点续传**
300-399 重定向
300 Multiple Choice 提供一系列地址供客户端选择重定向
**301 Moved Permanently 永久重定向**，默认可缓存，搜索引擎应更新链接
**302 Found 临时重定向**，默认不缓存，除非显示指定

> **永久重定向**
>
> 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的 URI 保存为书签，此时会按照 Location 中新的 URI 重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。
>
> 该操作比较危险，需要谨慎操作：如果设置了 301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。
>
> **使用场景：**
>
> - 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
> - 在搜索引擎的搜索结果中出现了不带 www 的域名，而带 www 的域名却没有收录，这个时候可以用 301 重定向来告诉搜索引擎我们目标的域名是哪一个。
>
> **临时重定向**
>
> 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回 302 代码，搜索引擎认为新的网址只是暂时的。
>
> **使用场景：**
>
> - 当我们在做活动时，登录到首页自动重定向，进入活动页面。
> - 未登陆的用户访问用户中心重定向到登录页面。
> - 访问 404 页面重新定向到首页。

303 See Other 临时重定向，必须 GET 请求(**301 和 302 都是会把请求方法改成 get** )
**304 Not Modified 未修改，不含响应体**
307 Temporary Redirect 临时重定向，默认不缓存，除非显示指定，不改变请求方法和请求体
308 Permanent Redirect 永久重定向，默认可缓存，搜索引擎应更新链接，不改变请求方法和请求体
400-499 客户端错误
**400 Bad Request 请求语义或参数有误**，不应重复请求
**401 Unauthorized 请求需身份验证或验证失败**
**403 Forbidden 拒绝，不应重复请求**
**404 Not Found 未找到，无原因**
405 Method Not Allowed 不允许的请求方法，并返回 Allow 允许的请求方法列表
406 Not Acceptable 无法根据请求条件，返回响应体
407 Proxy Authentication Required 请求需在代理服务器上身份验证
408 Request Timeout 请求超时
409 Conflict 请求冲突，响应应包含冲突原因
410 Gone 资源已被永久移除
411 Length Required 请求头需添加 Content-Length
412 Precondition Failed 非 GETPOST 请求外，If-Unmodified-Since 或 If-None-Match 规定先决条件无法满足
413 Payload Too Large 请求体数据大小超过服务器处理范围
414 URI Too Long URL 过长，查询字符串过长时，应使用 POST 请求
415 Unsupported Media Type 请求文件类型服务端不支持
416 Range Not Satisfiable 请求头 Range 与资源可用范围不重合
417 Expectation Failed 服务端无法满足客户端通过 Expect 设置的期望响应
421 Misdirected Request HTTP2 下链接无法复用时返回
425 Too Early 请求有重放攻击风险
426 Upgrade Required 客端应按响应头 Upgrade 的协议列表中的协议重新请求
428 Precondition Required 没有符合 If-Match 的资源
429 Too Many Requests 请求频次超过服务端限制
431 Request Header Fields Too Large 请求头字段过大
451 Unavailable For Legal Reasons 因法律原因该资源不可用
500-511 服务端响应
**500 Internal Server Error 是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。**
**501 Not Implemented 请求方法不被服务器支持**
**502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。**

**503 Service Unavailable 服务端临时不可用，建议返回 Retry-After，搜索引擎爬虫应一段时间再次访问这个 URL**
**504 Gateway Timeout 网关超时，通常是服务端过载**
505 HTTP Version Not Supported 请求的 HTTP 协议版本不被支持
506 Variant Also Negotiates 内部服务器配置错误
510 Not Extended 不支持 HTTP 扩展
511 Network Authentication Required 需要身份验证，常见于公用 WIFI

#### ==缓存==

- 浏览器本地缓存（localstorage、sessionstorage、cookie）

  localstorage、sessionstorage、cookie 的区别如下：

  - cookie 是网站为了标识用户身份而存储在用户本地终端上的数据，通常经过加密。cookie 数据始终在同源的 http 请求中携带，即使不需要，也会在浏览器和服务器间来回传递。cookie 的大小限制为 4KB 左右
  - localstorage 和 sessionstorage 是单纯的前端存储，不会自动把数据发给服务器，仅在本地保存。localstorage 和 sessionstorage 的大小限制为 5MB 左右
  - cookie、localstorage 和 sessionstorage 的有效期不同。cookie 可以设置过期时间，如果没有设置，则默认为浏览器关闭时失效。localstorage 永久有效，除非用户手动清除。sessionstorage 仅在当前浏览器窗口有效，关闭窗口或标签页后就会被清除
  - cookie、localstorage 和 sessionstorage 的作用域不同。cookie 在所有同源窗口中共享。localstorage 也在所有同源窗口中共享。sessionstorage 只在同一个浏览器窗口中共享，不同浏览器或标签页之间不共享

- http 缓存

  缓存寻找过程

  ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230322204542.png)

  协商缓存：

  - Etag、If-None-Match
  - Last-Modified、If-Modified-Since

  **使用场景**

  强缓存适用于一些不经常变化或者可以接受一定延迟更新的资源，比如静态文件、图片、字体等。

  协商缓存适用于一些经常变化或者需要及时更新的资源，比如动态页面、新闻、文章等。

  ##### no-cache 和 no-store 的区别

  - no-cache 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用
  - no-store 彻底得禁用缓冲，本地和代理服务器都不缓存，每次都从服务器获取

  > no-cache 并不意味着不缓存。 事实上，这意味着在对每个请求使用您可能拥有的任何缓存响应之前“使用服务器重新验证”。
  >
  > 另一方面，must-revalidate 只需要在资源被认为陈旧时重新验证。
  >
  > 如果服务器说资源仍然有效，那么缓存可以用它的表示进行响应，从而减轻服务器重新发送整个资源的需要。
  >
  > no-store 实际上是完整的不缓存指令，旨在防止以任何形式的缓存存储表示。
  >
  > no-store 指令的目的是防止无意中释放或保留敏感信息（例如，在备份磁带上）。 no-store 指令适用于整个消息，可以在响应或请求中发送。如果在请求中发送，则缓存不得存储此请求或对它的任何响应的任何部分。如果在响应中发送，则缓存不得存储此响应或引发它的请求的任何部分。该指令适用于非共享和共享缓存。 “不得存储”在此上下文中意味着缓存不得有意将信息存储在非易失性存储中，并且必须尽最大努力在转发信息后尽快从易失性存储中删除信息。即使此指令与响应相关联，用户也可能在缓存系统之外显式存储此类响应（例如，使用“另存为”对话框）。历史缓冲区可以存储这样的响应作为其正常操作的一部分。该指令的目的是满足某些用户和服务作者的既定要求，他们担心通过对缓存数据结构的意外访问而意外发布信息。虽然在某些情况下使用此指令可能会改善隐私，但我们警告说，它无论如何都不是确保隐私的可靠或充分机制。特别是，恶意或受损的缓存可能无法识别或遵守此指令，并且通信网络可能容易受到窃听。

#### ==从输入一个 URL 到页面渲染完毕的过程==

- 大概过程如下：

  （1）**解析 URL：**首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

  （2）**缓存判断：**浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

  （3）**DNS 解析：**下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

  （4）**获取 MAC 地址：**当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

  （5）**TCP 三次握手：**下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

  （6）**HTTPS 握手：**如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

  （7）**返回数据：**当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

  （8）**页面渲染：**浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

  （9）**TCP 四次挥手：**最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

#### ==请求方法有哪些以及应用场景==

- 如下：

  - GET：获取服务器资源，如查询信息或下载文件。
  - POST：提交信息给服务器，如表单数据或上传文件。
  - PUT：传输文件，用于更新或创建指定资源。
  - HEAD：和 GET 方法一样，但是只返回响应头部，作用是确定 URL 的有效性和资源更新的时间。
  - DELETE：删除指定的资源，如删除用户或文章。
  - OPTIONS：查询请求服务器指定的资源所支持的方法，如查看某个 API 接口支持哪些操作。
  - PATCH：修改部分资源属性，如更新用户昵称或密码。
  - TRACE：回显服务器收到的请求，用于测试或诊断。
  - CONNECT：建立连接渠道，用于代理服务器转发请求。

- ==get 和 post 的区别==
  - **应用场景（幂等性）：**GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
  - **是否缓存：**因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
  - **发送的报文格式：**Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
  - **安全性：**Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为**请求的 url 会被保留在历史记录中**。
  - **请求长度：**浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
  - **参数类型：**post 的参数传递支持更多的数据类型。get 请求只能进行 url 编码（appliacation-x-www-form-urlencoded）,post 请求支持多种（multipart/form-data 等）。
  - 从**TCP**的角度：GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(**火狐**浏览器除外，它的 POST 请求只发一个 TCP 包)
- POST 和 PUT 请求的区别
  - PUT 请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次 PUT 操作，其结果并没有不同。（可以理解为时**更新数据**）
  - POST 请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是**创建数据**）

####

### 算法与数据结构

#### ==LC11.盛最多水的容器（这题做了好几遍了，也忘了好几遍了）==

#### ==LC354. 俄罗斯套娃信封问题==

### 知识广度

#### ==前端安全==

- crsf

  - 特点
    - 攻击一般发生在第三方网站，而不是被攻击网站；
    - 攻击利用用户在被攻击网站的登陆凭证(cookie)，冒充受害者提交操作，而不是直接窃取数据；
    - 整个过程，攻击者并不能获取到登录凭证，而是冒用；
    - 跨站请求可以用各种方式：img 图片的 src、a 标签、form 表单提交等等；
  - 过程

    1. 用户在浏览器中登录了受信任的网站 A，网站 A 返回一个包含用户身份信息的 cookie。
    2. 用户在未退出网站 A 的情况下，访问了攻击者的网站 B。
    3. 网站 B 返回一个包含攻击代码的页面，其中包含了一个指向网站 A 的请求。
    4. 浏览器在不知情的情况下，携带了网站 A 的 cookie 向网站 A 发起了请求。
    5. 网站 A 认为这是用户的合法请求，执行了攻击者的指令。

  - 防护手段

    1. 给 Cookie 设置合适的 SameSite

    当从 A 网站登录后，会从响应头中返回服务器设置的 `Cookie` 信息，而如果 `Cookie` 携带了 `SameSite=strict` 则表示完全禁用第三方站点请求头携带 `Cookie`，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 `Cookie`。`SameSite` 还有另外 2 个属性值：

    - `Lax` 是默认值，允许第三方站点的 `GET` 请求携带；
    - `None` 任何情况下都会携带；

    以下是一个响应头的 `Set-Cookie` 示例：

    ```text
    Set-Cookie: flavor=choco; SameSite=strict
    ```

    2. 同源检测

    在服务端，通过请求头中携带的 `Origin` 或者 `Referer` 属性值进行判断请求是否来源同一站点，同时服务器应该优先检测 `Origin`。为了安全考虑，相比于 `Referer`，`Origin` 只包含了域名而不带路径。

    另外，CSRF 大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。

    - origin 和 referer 的区别
      - origin 只包含域名信息，而 referer 包含完整的 URL 信息，包括路径。
      - origin 主要用于 CORS 请求和 POST 请求，而 referer 用于所有类型的请求。
      - origin 更加保护用户的隐私，因为它不会泄露路径信息。有些浏览器为了保护用户隐私，会省略 referer 头。

    **综上所述：**同源验证是一个相对简单的防范方法，能够防范绝大多数的 CSRF 攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。

    > 应该是 Cookie 有原本站点信息，就是通过比较 `Origin` 和 Cookie 里面的信息

    3. CSRF Token

    大概过程是可以分成 2 步骤：

    - 在浏览器向服务器发起请求时，服务器生成一个 `CSRF Token`。`CSRF Token` 其实就是服务器生成的随机字符串，然后将该字符串植入到返回的页面中，通常是放到表单的隐藏输入框中，这样能够很好的保护 `CSRF Token` 不被泄漏；

    ```text
    <form action="https://platforma.com/withdraw" method="POST">
        <input type="hidden" name="csrf-token" value="nc98P987b">
        <input type="text" name="account">
        <input type="text" name="money">
        <input type="submit">
    </form>
    ```

    - 当浏览器再次发送请求的时候（比如转账），就需要携带这个 `CSRF Token` 值一并提交；
    - 服务器验证 `CSRF Token` 是否一致；从第三方网站发出的请求是无法获取用户页面中的 `CSRF Token` 值的。

    4. 身份验证（JWT）

- 跨域

  - 同源策略

    如果两个 `URL` 的协议、域名和端口都相同，我们就称这两个 `URL` 同源。

    比如，这个 `http://store.company.com/dir/page.html` 和下面这些 `URL` 相比源的结果如下：

    ```text
    http://store.company.com/dir2/other.html         // 同源，只有路径不同
    http://store.company.com/dir/inner/another.html  // 同源，只有路径不同
    https://store.company.com/secure.html            // 失败，协议不同
    http://news.company.com/dir/other.html           // 失败，域名不同
    http://store.company.com:81/dir/etc.html         // 失败，端口不同 ( http:// 默认端口是80)
    ```

    同源策略的限制

    - 限制了来自不同源的 `JavaScript` 脚本对当前 `DOM` 对象读和写的操作；
    - 限制了不同源的站点读取当前站点的 `Cookie`、`IndexDB`、`LocalStorage` 等数据；
    - 限制了通过 `XMLHttpRequest` 等方式将站点的数据发送给不同源的站点。

  - 解决方案
    - JSONP：利用\<script>标签没有跨域限制的原理，通过发送带有回调函数参数的 GET 请求，服务器返回数据拼接到回调函数中，浏览器执行回调函数获取数据。这种方法只支持 GET 请求。
    - CORS：跨源资源共享是一种机制，它使用额外的 HTTP 头来告诉浏览器允许不同源的网站访问资源。这种方法需要服务器端设置响应头，并且支持各种请求方式。
    - Nginx 反向代理：利用 Nginx 服务器将跨域请求转发为同源请求，从而绕过浏览器的限制。这种方法需要在 Nginx 进行额外配置，并且语义不清晰。
    - document.domain + iframe：只适用于主域相同子域不同的情况，通过设置两个页面的 document.domain 为相同值，然后通过 iframe 来实现通信。这种方法比较古老且局限性大。
    - postMessage：HTML5 提供了一个新的 API，可以实现不同窗口之间的数据传递，无论是否同源。这种方法比较灵活且安全。
    - WebSocket：HTML5 提供了一个新的协议，可以实现双向通信，并且没有跨域限制。这种方法需要服务器端支持 WebSocket 协议，并且可能存在兼容性问题。
    - window.name + iframe：利用 window.name 属性在不同页面之间传递数据，配合 iframe 来实现跨域通信。这种方法存在一定的安全风险，并且只能传递字符串类型的数据。
    - location.hash + iframe：利用 location.hash 属性在不同页面之间传递数据，配合 iframe 来实现跨域通信。这种方法存在一定的性能问题，并且只能传递字符串类型的数据。
    - proxy：利用后端服务器作为中间层来转发请求和响应，从而避免浏览器端的跨域问题。这种方法需要后端服务器进行额外开发和维护。

#### ==进程和线程==

- 概念

  进程和线程是操作系统中的基本概念。进程是指计算机中已运行程序的实例，它是一个动态的概念，可以看作是程序在执行过程中分配和管理资源的基本单位。线程是进程中的一个执行单元，它是操作系统进行运算调度的最小单位，由线程 ID、程序计数器、寄存器集合和堆栈组成。

  进程和线程的主要区别在于它们所使用的资源不同。每个进程都有自己独立的地址空间，而线程则共享进程的地址空间。这意味着，一个进程中的所有线程都可以访问相同的内存地址，而不需要进行额外的通信和同步。但是，这也意味着线程之间可能会相互干扰或冲突。

  另外，每个进程都有自己独立的系统资源，如文件句柄、网络连接等。这些资源在进程之间是不能共享的。而线程则共享相同的系统资源，如文件句柄、网络连接等。

  总之，进程和线程都是操作系统中非常重要的概念，它们在计算机系统中扮演着不同的角色。

- 通信
