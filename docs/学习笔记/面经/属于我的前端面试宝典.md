## ==巧用二八定律，用 20% 的时间去吸收 80% 的知识==

## 知识点查漏补缺列表（给我狠狠地串起来，形成自己的知识体系）

+ H5 + C3
+ JS

- [x] 闭包
  - [ ] 节流防抖（手写）
  - [ ] 模块化
    - [ ] CommonJS、AMD、CMD以及ES6
  - [ ] 设计模式（单例模式）
  - [ ] computed 和 watched
  - [x] 内存泄漏
  - [x] 网页内存使用情况
  - [x] 垃圾回收机制
    - [x] 标记计数和引用计数
    - [x] 内存碎片
      - [x] 新老生代
      - [ ] 更加深入的理解
  - [ ] 作用域
- [ ] 原型链
- [ ] ES6 新特性
  - [ ] promise
  - [ ] let, const
  - [ ] 箭头函数
  - [ ] 
- [ ] 数组和字符串的常见方法

+ Vue 

- [x] 对 Vue 的理解（通俗易懂版）
- [ ] SPA 与 MPA 的优劣
- [ ] Vue 生命周期
- [ ] 响应式原理
- [ ] Vue 双向绑定原理
- [ ] diff 算法

+ 前端工程化

- [ ] 移动端适配（多设备兼容）
  - [ ] 
- [ ] 单元测试
- [ ] 代码检测工具
- [ ] sourcemap
- [ ] 从零搭建前端系统，需要做哪些设计，选型

+ 计算机网络

- [ ] http、https
  - [ ] http1.0、http1.1、http2.0、http3.0
  - [ ] 怎么提供安全保障的
- [ ] tcp 三次握手、四次挥手

+ 算法与数据结构

- [ ] 了解一下红黑树

+ 知识广度（直接对着面经看）

- [ ] 前端安全
  - [ ] 跨域
  - [ ] 鉴权
  - [ ] ddos
  - [ ] csrf
  - [ ] xss
  - [ ] iframe安全问题
- [ ] 设计模式
- [ ] 数据库
- [ ] 操作系统
- [ ] Java

### JavaScript

#### ==闭包==

+ 闭包是什么？

  > 闭包是一个可以访问到外层函数里面的变量的函数。也可以说，闭包是一个函数以及其捆绑的周边环境状态（**lexical environment**，**词法环境**）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。闭包是由函数及其相关的引用环境组合而成的实体。

+ 闭包的作用以及使用场景

  > + 作用
  >   + 可以用来定义私有变量或者私有方法，避免变量污染（模块化）
  >   + 延长变量的生命周期，变量被内层函数所引用所以并不会被垃圾回收清除
  >   + 实现函数式编程的高阶函数（？）
  >   + 做一些缓存处理，例如单例模式、computed
  > + 使用场景
  >   + 节流防抖
  >
  >     ```js
  >     // throttle
  >     function throttle(fn, delay) {
  >         let timer = false;
  >         return function(...args) {
  >             if (timer) return;
  >             timer = true;
  >             timer = setTimeout(() => {
  >                 timer = false;
  >             }, delay);
  >             fn.apply(this, args)
  >         }
  >     }
  >     
  >     // debounce
  >     // 2023-3-16 写错了
  >     /*
  >     function debounce(fn, delay) {
  >         let timer = null;
  >         return function(...args) {
  >             if (timer) return;
  >             fn.apply(this, args);
  >             timer = setTimeout(() => {
  >                 timer = null; 
  >             }, delay);
  >         }
  >     }
  >     */
  >     ```
  >
  >     
  >
  >   + 模块化
  >
  >   + 单例模式、computed(这里可能会被往设计模式那边或者computed实现原理那边去问了)

+ 闭包的弊端

  > + 使用不当会导致内存泄漏。闭包会导致一些变量一直存在于内存中，即使它们已经不再需要。
  > + 性能问题。过度使用闭包，会使应用的内存一直得不到释放，增加内存使用量，堆栈内存变大，降低程序的性能和稳定性。同时由于闭包涉及到变量的作用域链查找，因此在访问闭包内部的变量时会比访问局部变量或全局变量更耗费时间。

+ ==如何查看网页的内存泄漏情况（内存情况）？==

  > 内存泄漏是指在应用程序中一块内存没有被正确释放或回收
  >
  > + 使用Chrome DevTools：在Chrome浏览器中，可以使用开发者工具（DevTools）来检查网页是否存在内存泄漏。打开Chrome DevTools，切换到“Memory”选项卡，然后进行堆快照（Heap Snapshot），查看对象的引用关系，以及是否存在被遗忘的对象。
  >
  >   > 以下是使用Heap Snapshot来分析内存泄漏的步骤：
  >   >
  >   > 1. 打开Chrome开发者工具，在Memory面板中选择“Take Heap Snapshot”（或者直接使用快捷键Ctrl + Shift + E）来记录一个初始状态的Heap Snapshot。
  >   > 2. 执行一些操作，让代码运行一段时间，然后再次记录一个Heap Snapshot。这个快照应该显示出之前快照中不存在的新对象，以及之前存在但现在已经不再使用的对象。
  >   > 3. 在两个Heap Snapshot之间，找到那些被创建但从未被释放的对象。这些对象很可能是内存泄漏的原因。可以使用“Comparison”选项卡来查看两个Heap Snapshot之间对象的差异。
  >   > 4. 确认哪些对象没有被正确释放。这些对象可能是事件监听器、定时器或未被清除的DOM元素等。使用“Retainers”选项卡来查找这些对象。
  >   > 5. 根据上述信息分析代码并修复内存泄漏问题。可以使用代码审查和调试器来找到问题所在。
  >   > 6. 修复问题后，再次运行应用程序并记录Heap Snapshot，确保内存泄漏已被解决。
  >   >
  >   > 需要注意的是，Heap Snapshot分析是一种有限的工具，可能会遇到一些限制。例如，它可能无法检测到循环引用等高级内存管理问题。因此，在使用Heap Snapshot分析内存泄漏时，需要结合其他工具和技术来进行综合诊断和修复。
  >
  > + 观察系统资源：如果网页存在内存泄漏，可能会导致浏览器消耗大量的系统资源，例如CPU占用率和内存占用率等。因此，可以使用系统监视器或任务管理器等工具来观察系统资源的变化，判断是否存在内存泄漏问题。
  >
  > + 其他的一些专业工具
  >
  > 一些可能会导致内存泄漏的情况
  >
  > + 未正确清除的事件监听器
  > + 未正确清除的事件定时器
  > + 未被清除的DOM元素
  > + 循环引用

#### ==垃圾回收机制==

+ 什么是垃圾回收机制（GC）？

  > `GC` 即 `Garbage Collection` ，程序工作过程中会产生很多 `垃圾`，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 `GC` 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，`GC` 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 `垃圾回收机制` 了
  >
  > 当然也不是所有语言都有 `GC`，一般的高级语言里面会自带 `GC`，比如 `Java、Python、JavaScript` 等，也有无 `GC` 的语言，比如 `C、C++` 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦

+ 垃圾是怎样产生的？

  > 垃圾产生的主要原因是内存中存在不再被引用的对象或变量，这些对象或变量无法被访问或使用（不可达），但它们仍然占用内存空间。垃圾收集器会定期执行垃圾回收操作，将这些垃圾对象从内存中清除，以释放内存空间供其他对象或变量使用。
  >
  > 内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。

+ 垃圾回收是怎样进行的？

> **标记清除算法**
>
> - 标记过程
>
>   当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
>
> - **策略**
>
>   标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 `JavaScript引擎` 在运行垃圾回收的频率上有所差异。
>
>   给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。
>
> - 大致整体过程：
>
>   - 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
>   - 然后从各个根对象开始遍历，把不是垃圾的节点改成1
>   - 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
>   - 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收
>
> - 优缺点
>
> > 优点
> >
> > 标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单，适用于短生命周期对象的垃圾回收。
> >
> > 缺点
> >
> > 需要遍历所有的对象，对于大量对象时性能较差。标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
>
> - **内存碎片**
>
>   > ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230316153917.png)
>   >
>   > 内存分配策略：
>   >
>   > - `First-fit`，找到大于等于 `size` 的块立即返回
>   > - `Best-fit`，遍历整个空闲列表，返回大于等于 `size` 的最小分块
>   > - `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 `size` 大小，并将该部分返回
>   > - 这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 `First-fit` 和 `Best-fit` 来说，考虑到分配的速度和效率 `First-fit` 是更为明智的选择
>   >
>   > 综上所述，标记清除算法或者说策略就有两个很明显的缺点
>   >
>   > - **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
>   > - **分配速度慢**，因为即便是使用 `First-fit` 策略，其操作仍是一个 `O(n)` 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
>   >
>   > **PS：标记清除算法的缺点补充**
>   >
>   > 归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了
>   >
>   > 而 **标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）
>   >
>   > ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230316155208.png)
>
> **引用计数算法**
>
> + 策略
>
>   引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下
>
> + **大致过程**
>
>   它的策略是跟踪记录每个变量值被使用的次数
>
>   - 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
>   - 如果同一个值又被赋给另一个变量，那么引用数加 1
>   - 如果该变量的值被其他的值覆盖了，则引用次数减 1
>   - 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存
>
> 在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子
>
> ```js
> function test(){
>   let A = new Object()
>   let B = new Object()
>   
>   A.b = B
>   B.a = A
> }
> ```
>
> 如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 `test` 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放
>
> 我们再**用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉**，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，**这也是后来放弃引用计数，使用标记清除的原因之一**
>
> + 优缺点
>
>   >优点
>   >
>   >引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，**也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾**
>   >
>   >而**标记清除算法需要每隔一段时间进行一次**，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 `GC`，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了
>   >
>   >缺点
>   >
>   >引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的

+ V8 引擎对垃圾回收进行了哪些优化？

   **分代式垃圾回收**

  试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了
  
  **新老生代**
  
  V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收
  
  新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大
  
  对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了
  
  **新生代垃圾回收**
  
  新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收，在 `Scavenge算法` 的具体实现中，主要采用了一种复制式的方法即 `Cheney算法` ，我们细细道来
  
  `Cheney算法` 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 `使用区`，一个是处于闲置状态的空间我们称之为 `空闲区`，如下图所示
  
  ![](https://raw.githubusercontent.com/eru-Ryuuzaki/myPic/master/img/20230316164723.png)
  
  新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作
  
  当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区
  
  当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理
  
  另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配
  
  **老生代垃圾回收**
  
  相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了
  
  首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象
  
  清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉
  
  前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间
  
  [更多优化可以看这篇文章](https://juejin.cn/post/6981588276356317214)

#### ==作用域==

### Vue

#### ==你是怎么理解 Vue 的？通俗易懂地讲一下==

Vue.js（/vjuː/，或简称为Vue）是一个**用于创建用户界面的开源JavaScript框架**，也是**一个创建单页应用的Web应用框架**。

Vue 是一套用于构建用户界面的**渐进式MVVM框架**。那怎么理解渐进式呢？渐进式含义：强制主张最少。

Vue.js包含了声明式渲染、组件化系统、客户端路由、大规模状态管理、构建工具、数据持久化、跨平台支持等，但**在实际开发中，并没有强制要求开发者之后某一特定功能，而是根据需求逐渐扩展**。

Vue所**关注的核心是 MVC 模式中的视图层**，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互。

Vue.js的核心库只关心视图渲染，且**由于渐进式的特性，Vue.js便于与第三方库或既有项目整合**。Vue.js 实现了一套声明式渲染引擎，并在runtime或者预编译时将声明式的模板编译成渲染函数，挂载在观察者 Watcher 中，在渲染函数中（touch），响应式系统使用响应式数据的getter方法对观察者进行依赖收集（Collect as Dependency），使用响应式数据的setter方法通知（notify）所有观察者进行更新，此时观察者 Watcher 会触发组件的渲染函数（Trigger re-render），组件执行的 render 函数，生成一个新的 Virtual DOM Tree，此时 Vue 会对新老 Virtual DOM Tree 进行 Diff，查找出需要操作的真实 DOM 并对其进行更新。

Vue的核心特性有：

- 采用了MVVM(Model-View-ViewModel)的软件架构设计模式，实现了数据和视图的双向绑定，让我们可以专注于业务逻辑，而不用操作DOM。
- 提供了指令、过滤器、插槽、混入等功能，增强了模板的表现力和灵活性。
- 支持组件化开发，可以把复杂的页面拆分成可复用的组件，提高代码的可维护性和复用性。
- 采用虚拟DOM和diff算法，优化了渲染性能，只更新变化的部分。
- 支持服务端渲染、单文件组件、状态管理等高级特性，适应不同规模和场景的项目需求。

#### ==MVC 和 MVVC 的区别==

**它们之间的区别主要在于它们如何分离视图（View）和数据（Model）之间的交互以及如何管理业务逻辑（Presenter 或 ViewModel）。**

MVC 即模型、视图、控制器（Model View Controller）

> 简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。**controller**在这里执行的的就是别墅里面的“**管家**”的作用。

- View 接受用户交互请求
- View 将请求转交给Controller处理
- Controller 操作Model进行数据更新保存
- 数据更新保存之后，Model会通知View更新
- View 更新变化数据使用户得到反馈

MVVM 即模型、视图、视图模型（Model-View-ViewModel），**ViewModel**是MVVM这栋别墅的“**管家**”

- View 接收用户交互请求
- View 将请求转交给ViewModel
- ViewModel 操作Model数据更新
- Model 更新完数据，通知ViewModel数据发生变化
- ViewModel 更新View数据

> MVVM设计模式是自动化的，vue就是采取了这种设计模式，真正把数据和视图分离开的是MVVM模式，并不是MVC，因为controller当中有大量手工的DOM操作，只要界面改变，controller中的代码必须要更改（jquery），比如你可以想象一下，你页面当中元素的位置变了，你的选择器是不是肯定要变，选择器就写在DOM操作里面，这就是MVC和MVVM两种设计模式的区别。

```js
// MVC 
// Model 
var data = {name: 'Tom', age: 18}; 
// View 
var view = document.getElementById('view'); 
view.innerHTML = data.name + ' is ' + data.age + ' years old.'; 
// Controller 
var button = document.getElementById('button'); 
button.onclick = function() { 
  data.age++; view.innerHTML = data.name + ' is ' + data.age + ' years old.'; 
};

// MVP 
// Model 
var data = {name: ‘Tom’, age: 18}; 
// View 
var view = document.getElementById('view'); 
function render(data) { 
  view.innerHTML = data.name + ' is ' + data.age + ' years old.'; 
} 
render(data); 
// Presenter 
var button = document.getElementById('button'); 
button.onclick = function() { 
    data.age++; render(data); 
};

// MVVM 
// Model 
var data = {name: 'Tom', age: 18}; 
// View 
var view = document.getElementById('view'); 
view.innerHTML = '{{name}} is {{age}} years old.'; 
// ViewModel 
var vm = new Vue({ el: '#view', data: data, }); 
var button = document.getElementById('button'); 
button.onclick = function() { vm.age++; };
```

[可以看一下这个视频方便理解](https://www.bilibili.com/video/BV1Ji4y1U7Y1/?spm_id_from=333.337.search-card.all.click&vd_source=a4fc242d78932c3766e19f28fae791f7)

#### ==Vue 和 React 的区别==

#### ==Vue 双向绑定原理==

### 算法与数据结构

#### ==LC11.盛最多水的容器（这题做了好几遍了，也忘了好几遍了）==

#### ==LC354. 俄罗斯套娃信封问题==

